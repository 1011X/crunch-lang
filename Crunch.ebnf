Program ::= ( FunctionDeclaration | TypeDeclaration | Import )*

FunctionDeclaration ::= Decorator* Visibility? 'fn' Ident ( '<' Ident ','? '>' )? '(' FunctionArguments* ')' ( '->' Ident )? '\n' Body End
FunctionArguments ::= ( Ident ( ':' Ident )? ) | ( FunctionArguments ',' )

TypeDeclaration ::= Visibility? 'type' Ident ( '<' Ident ',' '>' )? '\n' TypeArguments* Function* End
TypeArguments ::= ( ( Ident ':' Ident ) | TypeArguments ',' ) '\n'

Import ::= 'import' ImportDestination? String ( 'exposing' ( '*' | ( Ident ( 'as' Ident )? ',' ? )+ ) )? '\n'
ImportDestination ::= 'lib' | 'pkg'

VarDeclaration ::= 'let' Ident ( ':' Ident )? '=' Expr '\n'
Assignment ::= Ident Assigner Expr '\n'

If ::= 'if' Expr '\n' Body ElseIf* Else? End
ElseIf ::= 'else if' Expr '\n' Body
Else ::= 'else' '\n' Body

While ::= 'while' Expr '\n' Body ( 'then' '\n' Body )? End
Loop ::= 'loop' Body 'end'
For ::= 'for' Ident 'in' Expr '\n' Body ( 'then' '\n' Body )?  End

BinaryOperation ::= Expr BinaryOperand Expr
Comparison ::= Expr Comparator Expr

BinaryOperand ::= ( '+' | '-' | '*' | '/' | '^' | '|' | '&' ) ( '?' | '!' )?
Comparator ::= '==' | '<=' | '>=' | '<' | '>'
Assigner ::= '=' | ( BinaryOperand '=' )

Ident ::= [a-zA-Z_][a-zA-Z0-9_]*
Literal ::= String | Integer | Boolean
String ::= '"' [^"]* '"' | "'" [^']* "'"
Integer ::= [0-9]+
Boolean ::= 'true' | 'false'
Range ::= Expr '..' Expr

Decorator ::= '@' Ident ( '(' DecoratorArgs* ')' )? '\n'
DecoratorArgs ::= ( Ident | Literal ) | ( DecoratorArgs ',' ( Ident | Literal ) )
Visibility ::= 'exposed' | 'lib'
End ::= 'end'

Expr ::= Literal | Range | Comparison | BinaryOperation | Ident | ( '(' Expr ')' ) | IndexArray | InlineConditional | FunctionCall
Array ::= '[' ( Expr | ArrayElements ) ']'
ArrayElements ::= Expr | ( ArrayElements ',' Expr )
IndexArray ::= Expr '[' Expr ']'
InlineConditional ::= Expr if Expr else Expr
FunctionCall ::= Expr '(' FunctionCallArgs* ')'
FunctionArgs ::= Expr | ( FunctionArgs ',' Expr )

Statement ::= If | While | Loop | For | VarDeclaration | Return | Continue | Break | ( Expr '\n' )
Return ::= 'return' Expr? '\n'
Continue ::= 'continue' '\n'
Break ::= 'break' Expr? '\n'
Match ::= 'match' Expr '\n' ( Ident ( 'where' Expr )? '=>' '\n' Statement+ 'end'

Body ::= Statement+ | 'empty'
