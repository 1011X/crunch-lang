:: Declare a type
type Syven
    :: `name` will be of the `str` type
    name: str
    :: `age` will be of the `int` type
    age: int

    fn new(name: str, age: int) -> Self
        :: Construct a type
        Syven {
            name: name,
            age: age,
        }
    end

    fn greet(self) -> unit
        println("Hello {}! You are {} years old!\n", self.name, self.age)
    end
end

:: Functions can also be untyped
fn hello(name, age)
    println("Hello {}! You are {} years old!\n", name, age)
end

:: This untyped function will be desugared into a generic function like this
fn hello<T, E>(name: T, age E) -> unit
    println("Hello {}! You are {} years old!\n", name, age)
end

:: Functions that do not specify a return type default to `unit`
fn main()
    let name: str = "Syven"
    let age: nullable<int> = null
    age := 22

    hello(name, age)

    let syv = Syven {
        name: "Syven",
        age: 22,
    }
    syv.greet()

    if syv.name != 'Syven'
        println("You aren't Syven!")
    else
        syv.greet()
    end

    let syv = Syven.new("Syven", 22)
    syv.greet()
end

:: Importing a file (Note: Uses a relative path delimited by `.`)
import 'directory.file'
:: This will expose `file`, allowing usage like `file.foo()`

:: Aliasing imports
import 'directory.file' as Bar
:: Access is now aliased into `Bar`, allowing usage like `Bar.foo()`

:: Importing from a file
import 'directory.file' exposing Fizz
:: Now the only thing exposed from `file` is `Fizz`

:: Importing multiple things from a file
import 'directory.file' exposing Fizz, Buzz, Bar
:: This also allows aliasing
import 'directory.file' exposing Fizz as MyFizz, Buzz as MyBuzz, Bar as MyBar

:: Importing everything from a file
import 'directory.file' exposing *
:: Now everything from `file` is exposed

:: Importing a package/dependency
:: The syntax is the same as for importing files, except the keyword `pkg` is used after `import`
import pkg 'rand'

:: Importing a dynamic library
:: The syntax is the same as for importing files, except the keyword `lib` is used after `import`
import lib 'my_library'
```

import build exposing * :: Note: `build` is an intrinsic package, and so no decorator or quotes are needed

:: Specify package information
let package = Package
    name: "package-name",                   :: The name of the package
    description: "A Crunch package!",       :: The description of the package (Optional)
    authors: ["Author <email@domain.com>"], :: The author(s) of the package (Optional)
    version: "0.1.0",                       :: The version of your package (Optional)
    homepage: "yourwebsite.com",            :: A link to the homepage of your package (Optional)
    repository: "github.com/yourpackage",   :: A link to the repository of your package (Optional)
    license: "MIT",                         :: The license your package is under (Optional)
    license_file: "./LICENSE-MIT",                  :: The license file of your package (Optional, only needed for non-standard licenses)
    readme: "README.md",                    :: The link you your readme file (Optional)
    build: "build.crunch",                  :: The build script of your package (Optional)
end

:: Specify dependencies
:: Dependencies can also be specified in their own variables, to be inserted into the `dependencies` vector
let dependency = Dependency
    name: "some-package",          :: The package's name (Required)
    version: "1.0.0",              :: The version of the package to use (Required)
    git: "github.com/package.git", :: A link to the repository of the package
end

:: The dependencies vector, where all dependencies will be inserted in order to be included
let dependencies: [Dependency] = [
    { name: "dependency-name", version: "0.1.0" }, :: Inline dependency
    dependency,                                    :: Previously declared dependency
]

build(package, dependencies) :: `build` takes in a `Package` and a `[Dependency]`