/// Helper types
mod newtypes {
    use derive_more::{
        Add, AddAssign, Constructor, Display, From, Into, Mul, MulAssign, Sub, SubAssign,
    };
    impl std::ops::Add for Index {
        type Output = Self;
        fn add(self, other: Self) -> Self::Output {
            Self(self.0 + other.0)
        }
    }
    impl std::ops::AddAssign for Index {
        fn add_assign(&mut self, other: Self) {
            self.0 += other.0;
        }
    }
    impl std::ops::Sub for Index {
        type Output = Self;
        fn sub(self, other: Self) -> Self::Output {
            Self(self.0 - other.0)
        }
    }
    impl std::ops::SubAssign for Index {
        fn sub_assign(&mut self, other: Self) {
            self.0 -= other.0;
        }
    }
    impl std::ops::Add for Register {
        type Output = Self;
        fn add(self, other: Self) -> Self::Output {
            Self(self.0 + other.0)
        }
    }
    impl std::ops::AddAssign for Register {
        fn add_assign(&mut self, other: Self) {
            self.0 += other.0;
        }
    }
    impl std::ops::Sub for Register {
        type Output = Self;
        fn sub(self, other: Self) -> Self::Output {
            Self(self.0 - other.0)
        }
    }
    impl std::ops::SubAssign for Register {
        fn sub_assign(&mut self, other: Self) {
            self.0 -= other.0;
        }
    }
    impl std::ops::Deref for Index {
        type Target = u32;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl From<Index> for u32 {
        fn from(ty: Index) -> u32 {
            ty.0
        }
    }
    impl std::fmt::Display for Index {
        fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            fmt.write_fmt(::core::fmt::Arguments::new_v1(
                &[""],
                &match (&self.0,) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            ))
        }
    }
    impl std::ops::Deref for Register {
        type Target = u8;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
    impl From<Register> for u8 {
        fn from(ty: Register) -> u8 {
            ty.0
        }
    }
    impl std::fmt::Display for Register {
        fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            fmt.write_fmt(::core::fmt::Arguments::new_v1(
                &[""],
                &match (&self.0,) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            ))
        }
    }
    /// The instruction index for the VM
    #[repr(transparent)]
    pub struct Index(pub u32);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Index {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Index(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("Index");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for Index {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Index {
        #[inline]
        fn clone(&self) -> Index {
            {
                let _: ::core::clone::AssertParamIsClone<u32>;
                *self
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Index {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Index {
        #[inline]
        fn eq(&self, other: &Index) -> bool {
            match *other {
                Index(ref __self_1_0) => match *self {
                    Index(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Index) -> bool {
            match *other {
                Index(ref __self_1_0) => match *self {
                    Index(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::core::marker::StructuralEq for Index {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for Index {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<u32>;
            }
        }
    }
    #[repr(transparent)]
    pub struct Register(pub u8);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for Register {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Register {
        #[inline]
        fn clone(&self) -> Register {
            {
                let _: ::core::clone::AssertParamIsClone<u8>;
                *self
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Register {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Register {
        #[inline]
        fn eq(&self, other: &Register) -> bool {
            match *other {
                Register(ref __self_1_0) => match *self {
                    Register(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Register) -> bool {
            match *other {
                Register(ref __self_1_0) => match *self {
                    Register(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::core::marker::StructuralEq for Register {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for Register {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<u8>;
            }
        }
    }
    impl std::fmt::Debug for Register {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.write_fmt(::core::fmt::Arguments::new_v1_formatted(
                &["Rx"],
                &match (&self.0,) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
                &[::core::fmt::rt::v1::Argument {
                    position: ::core::fmt::rt::v1::Position::At(0usize),
                    format: ::core::fmt::rt::v1::FormatSpec {
                        fill: ' ',
                        align: ::core::fmt::rt::v1::Alignment::Unknown,
                        flags: 8u32,
                        precision: ::core::fmt::rt::v1::Count::Implied,
                        width: ::core::fmt::rt::v1::Count::Is(3usize),
                    },
                }],
            ))
        }
    }
    pub struct Bytecode<'a>(&'a [u8]);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::core::fmt::Debug for Bytecode<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Bytecode(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("Bytecode");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::core::marker::Copy for Bytecode<'a> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::core::clone::Clone for Bytecode<'a> {
        #[inline]
        fn clone(&self) -> Bytecode<'a> {
            {
                let _: ::core::clone::AssertParamIsClone<&'a [u8]>;
                *self
            }
        }
    }
    impl<'a> ::core::marker::StructuralPartialEq for Bytecode<'a> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::core::cmp::PartialEq for Bytecode<'a> {
        #[inline]
        fn eq(&self, other: &Bytecode<'a>) -> bool {
            match *other {
                Bytecode(ref __self_1_0) => match *self {
                    Bytecode(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Bytecode<'a>) -> bool {
            match *other {
                Bytecode(ref __self_1_0) => match *self {
                    Bytecode(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl<'a> ::core::marker::StructuralEq for Bytecode<'a> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::core::cmp::Eq for Bytecode<'a> {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<&'a [u8]>;
            }
        }
    }
    impl<'a> Bytecode<'a> {
        #[inline]
        pub fn validate(bytes: &'a [u8]) -> Result<Self, &'static str> {
            Ok(Self(bytes))
        }
    }
}
