#![allow(
    unused_imports,
    non_snake_case,
    non_camel_case_types,
    non_upper_case_globals,
    unused_parens,
    non_shorthand_field_patterns,
    dead_code,
    overflowing_literals,
    unreachable_patterns,
    unused_variables,
    clippy::unknown_clippy_lints,
    clippy::missing_safety_doc
)]

use std::convert::TryFrom;
use std::ffi;
use std::fmt;
use std::hash::Hash;
use std::result;

use serde::Deserialize;
use serde::Serialize;

use differential_datalog::ddval::*;
use differential_datalog::decl_ddval_convert;
use differential_datalog::int::*;
use differential_datalog::program::*;
use differential_datalog::record;
use differential_datalog::record::FromRecord;
use differential_datalog::record::IntoRecord;
use differential_datalog::record::RelIdentifier;
use differential_datalog::uint::*;

use fnv::FnvHashMap;
use once_cell::sync::Lazy;
use ordered_float::OrderedFloat;

use types::*;

/* FlatBuffers bindings generated by `ddlog` */
#[cfg(feature = "flatbuf")]
pub mod flatbuf;

impl TryFrom<&RelIdentifier> for Relations {
    type Error = ();

    fn try_from(rel_id: &RelIdentifier) -> result::Result<Self, Self::Error> {
        match rel_id {
            RelIdentifier::RelName(rname) => Relations::try_from(rname.as_ref()),
            RelIdentifier::RelId(id) => Relations::try_from(*id),
        }
    }
}

pub mod Value {
    use super::*;
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct __Bitval32(pub u32);
    impl abomonation::Abomonation for __Bitval32 {}
    impl fmt::Display for __Bitval32 {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl record::IntoRecord for __Bitval32 {
        fn into_record(self) -> record::Record {
            self.0.into_record()
        }
    }
    impl record::Mutator<__Bitval32> for record::Record {
        fn mutate(&self, v: &mut __Bitval32) -> result::Result<(), std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    decl_ddval_convert! {__Bitval32}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct __Bitval64(pub u64);
    impl abomonation::Abomonation for __Bitval64 {}
    impl fmt::Display for __Bitval64 {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl record::IntoRecord for __Bitval64 {
        fn into_record(self) -> record::Record {
            self.0.into_record()
        }
    }
    impl record::Mutator<__Bitval64> for record::Record {
        fn mutate(&self, v: &mut __Bitval64) -> result::Result<(), std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    decl_ddval_convert! {__Bitval64}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct __Tuple0__(pub ());
    impl abomonation::Abomonation for __Tuple0__ {}
    impl fmt::Display for __Tuple0__ {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl record::IntoRecord for __Tuple0__ {
        fn into_record(self) -> record::Record {
            self.0.into_record()
        }
    }
    impl record::Mutator<__Tuple0__> for record::Record {
        fn mutate(&self, v: &mut __Tuple0__) -> result::Result<(), std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    decl_ddval_convert! {__Tuple0__}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct __Tuple4____Bitval64___Bitval64___Bitval64___Bitval64(pub (u64, u64, u64, u64));
    impl abomonation::Abomonation for __Tuple4____Bitval64___Bitval64___Bitval64___Bitval64 {}
    impl fmt::Display for __Tuple4____Bitval64___Bitval64___Bitval64___Bitval64 {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl record::IntoRecord for __Tuple4____Bitval64___Bitval64___Bitval64___Bitval64 {
        fn into_record(self) -> record::Record {
            self.0.into_record()
        }
    }
    impl record::Mutator<__Tuple4____Bitval64___Bitval64___Bitval64___Bitval64> for record::Record {
        fn mutate(
            &self,
            v: &mut __Tuple4____Bitval64___Bitval64___Bitval64___Bitval64,
        ) -> result::Result<(), std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    decl_ddval_convert! {__Tuple4____Bitval64___Bitval64___Bitval64___Bitval64}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct Errors(pub super::Errors);
    impl abomonation::Abomonation for Errors {}
    impl fmt::Display for Errors {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl record::IntoRecord for Errors {
        fn into_record(self) -> record::Record {
            self.0.into_record()
        }
    }
    impl record::Mutator<Errors> for record::Record {
        fn mutate(&self, v: &mut Errors) -> result::Result<(), std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    decl_ddval_convert! {Errors}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct Expressions(pub super::Expressions);
    impl abomonation::Abomonation for Expressions {}
    impl fmt::Display for Expressions {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl record::IntoRecord for Expressions {
        fn into_record(self) -> record::Record {
            self.0.into_record()
        }
    }
    impl record::Mutator<Expressions> for record::Record {
        fn mutate(&self, v: &mut Expressions) -> result::Result<(), std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    decl_ddval_convert! {Expressions}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct Functions(pub super::Functions);
    impl abomonation::Abomonation for Functions {}
    impl fmt::Display for Functions {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl record::IntoRecord for Functions {
        fn into_record(self) -> record::Record {
            self.0.into_record()
        }
    }
    impl record::Mutator<Functions> for record::Record {
        fn mutate(&self, v: &mut Functions) -> result::Result<(), std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    decl_ddval_convert! {Functions}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct Items(pub super::Items);
    impl abomonation::Abomonation for Items {}
    impl fmt::Display for Items {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl record::IntoRecord for Items {
        fn into_record(self) -> record::Record {
            self.0.into_record()
        }
    }
    impl record::Mutator<Items> for record::Record {
        fn mutate(&self, v: &mut Items) -> result::Result<(), std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    decl_ddval_convert! {Items}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct Literals(pub super::Literals);
    impl abomonation::Abomonation for Literals {}
    impl fmt::Display for Literals {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl record::IntoRecord for Literals {
        fn into_record(self) -> record::Record {
            self.0.into_record()
        }
    }
    impl record::Mutator<Literals> for record::Record {
        fn mutate(&self, v: &mut Literals) -> result::Result<(), std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    decl_ddval_convert! {Literals}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct Statements(pub super::Statements);
    impl abomonation::Abomonation for Statements {}
    impl fmt::Display for Statements {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl record::IntoRecord for Statements {
        fn into_record(self) -> record::Record {
            self.0.into_record()
        }
    }
    impl record::Mutator<Statements> for record::Record {
        fn mutate(&self, v: &mut Statements) -> result::Result<(), std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    decl_ddval_convert! {Statements}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct TypedExpressions(pub super::TypedExpressions);
    impl abomonation::Abomonation for TypedExpressions {}
    impl fmt::Display for TypedExpressions {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl record::IntoRecord for TypedExpressions {
        fn into_record(self) -> record::Record {
            self.0.into_record()
        }
    }
    impl record::Mutator<TypedExpressions> for record::Record {
        fn mutate(&self, v: &mut TypedExpressions) -> result::Result<(), std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    decl_ddval_convert! {TypedExpressions}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct Types(pub super::Types);
    impl abomonation::Abomonation for Types {}
    impl fmt::Display for Types {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl record::IntoRecord for Types {
        fn into_record(self) -> record::Record {
            self.0.into_record()
        }
    }
    impl record::Mutator<Types> for record::Record {
        fn mutate(&self, v: &mut Types) -> result::Result<(), std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    decl_ddval_convert! {Types}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct VariableScopes(pub super::VariableScopes);
    impl abomonation::Abomonation for VariableScopes {}
    impl fmt::Display for VariableScopes {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl record::IntoRecord for VariableScopes {
        fn into_record(self) -> record::Record {
            self.0.into_record()
        }
    }
    impl record::Mutator<VariableScopes> for record::Record {
        fn mutate(&self, v: &mut VariableScopes) -> result::Result<(), std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    decl_ddval_convert! {VariableScopes}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct Variables(pub super::Variables);
    impl abomonation::Abomonation for Variables {}
    impl fmt::Display for Variables {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl record::IntoRecord for Variables {
        fn into_record(self) -> record::Record {
            self.0.into_record()
        }
    }
    impl record::Mutator<Variables> for record::Record {
        fn mutate(&self, v: &mut Variables) -> result::Result<(), std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    decl_ddval_convert! {Variables}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct VariablesInScope(pub super::VariablesInScope);
    impl abomonation::Abomonation for VariablesInScope {}
    impl fmt::Display for VariablesInScope {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl record::IntoRecord for VariablesInScope {
        fn into_record(self) -> record::Record {
            self.0.into_record()
        }
    }
    impl record::Mutator<VariablesInScope> for record::Record {
        fn mutate(&self, v: &mut VariablesInScope) -> result::Result<(), std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    decl_ddval_convert! {VariablesInScope}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct hir_Type(pub super::hir_Type);
    impl abomonation::Abomonation for hir_Type {}
    impl fmt::Display for hir_Type {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl record::IntoRecord for hir_Type {
        fn into_record(self) -> record::Record {
            self.0.into_record()
        }
    }
    impl record::Mutator<hir_Type> for record::Record {
        fn mutate(&self, v: &mut hir_Type) -> result::Result<(), std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    decl_ddval_convert! {hir_Type}
    #[derive(
        Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug,
    )]
    pub struct internment_Intern__hir_Literal(pub super::internment_Intern<super::hir_Literal>);
    impl abomonation::Abomonation for internment_Intern__hir_Literal {}
    impl fmt::Display for internment_Intern__hir_Literal {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            self.clone().into_record().fmt(f)
        }
    }
    impl record::IntoRecord for internment_Intern__hir_Literal {
        fn into_record(self) -> record::Record {
            self.0.into_record()
        }
    }
    impl record::Mutator<internment_Intern__hir_Literal> for record::Record {
        fn mutate(
            &self,
            v: &mut internment_Intern__hir_Literal,
        ) -> result::Result<(), std::string::String> {
            self.mutate(&mut v.0)
        }
    }
    //#[typetag::serde]
    decl_ddval_convert! {internment_Intern__hir_Literal}
}
impl TryFrom<&str> for Relations {
    type Error = ();
    fn try_from(rname: &str) -> result::Result<Self, Self::Error> {
        match rname {
            "Errors" => Ok(Relations::Errors),
            "Expressions" => Ok(Relations::Expressions),
            "Functions" => Ok(Relations::Functions),
            "Items" => Ok(Relations::Items),
            "Literals" => Ok(Relations::Literals),
            "Statements" => Ok(Relations::Statements),
            "TypedExpressions" => Ok(Relations::TypedExpressions),
            "Types" => Ok(Relations::Types),
            "VariableScopes" => Ok(Relations::VariableScopes),
            "Variables" => Ok(Relations::Variables),
            "VariablesInScope" => Ok(Relations::VariablesInScope),
            "__Null" => Ok(Relations::__Null),
            "__Prefix_0" => Ok(Relations::__Prefix_0),
            _ => Err(()),
        }
    }
}
impl Relations {
    pub fn is_output(&self) -> bool {
        match self {
            Relations::Errors => true,
            Relations::Literals => true,
            Relations::TypedExpressions => true,
            Relations::VariablesInScope => true,
            _ => false,
        }
    }
}
impl Relations {
    pub fn is_input(&self) -> bool {
        match self {
            Relations::Expressions => true,
            Relations::Functions => true,
            Relations::Items => true,
            Relations::Statements => true,
            Relations::Types => true,
            Relations::VariableScopes => true,
            Relations::Variables => true,
            _ => false,
        }
    }
}
impl TryFrom<RelId> for Relations {
    type Error = ();
    fn try_from(rid: RelId) -> result::Result<Self, Self::Error> {
        match rid {
            0 => Ok(Relations::Errors),
            1 => Ok(Relations::Expressions),
            2 => Ok(Relations::Functions),
            3 => Ok(Relations::Items),
            4 => Ok(Relations::Literals),
            5 => Ok(Relations::Statements),
            6 => Ok(Relations::TypedExpressions),
            7 => Ok(Relations::Types),
            8 => Ok(Relations::VariableScopes),
            9 => Ok(Relations::Variables),
            10 => Ok(Relations::VariablesInScope),
            11 => Ok(Relations::__Null),
            12 => Ok(Relations::__Prefix_0),
            _ => Err(()),
        }
    }
}
pub fn relid2name(rid: RelId) -> Option<&'static str> {
    match rid {
        0 => Some(&"Errors"),
        1 => Some(&"Expressions"),
        2 => Some(&"Functions"),
        3 => Some(&"Items"),
        4 => Some(&"Literals"),
        5 => Some(&"Statements"),
        6 => Some(&"TypedExpressions"),
        7 => Some(&"Types"),
        8 => Some(&"VariableScopes"),
        9 => Some(&"Variables"),
        10 => Some(&"VariablesInScope"),
        11 => Some(&"__Null"),
        12 => Some(&"__Prefix_0"),
        _ => None,
    }
}
pub fn relid2cname(rid: RelId) -> Option<&'static ::std::ffi::CStr> {
    RELIDMAPC.get(&rid).copied()
}
/// A map of `RelId`s to their name as an `&'static str`
pub static RELIDMAP: ::once_cell::sync::Lazy<::fnv::FnvHashMap<Relations, &'static str>> =
    ::once_cell::sync::Lazy::new(|| {
        let mut map =
            ::fnv::FnvHashMap::with_capacity_and_hasher(13, ::fnv::FnvBuildHasher::default());
        map.insert(Relations::Errors, "Errors");
        map.insert(Relations::Expressions, "Expressions");
        map.insert(Relations::Functions, "Functions");
        map.insert(Relations::Items, "Items");
        map.insert(Relations::Literals, "Literals");
        map.insert(Relations::Statements, "Statements");
        map.insert(Relations::TypedExpressions, "TypedExpressions");
        map.insert(Relations::Types, "Types");
        map.insert(Relations::VariableScopes, "VariableScopes");
        map.insert(Relations::Variables, "Variables");
        map.insert(Relations::VariablesInScope, "VariablesInScope");
        map.insert(Relations::__Null, "__Null");
        map.insert(Relations::__Prefix_0, "__Prefix_0");
        map
    });
/// A map of `RelId`s to their name as an `&'static CStr`
pub static RELIDMAPC: ::once_cell::sync::Lazy<::fnv::FnvHashMap<RelId, &'static ::std::ffi::CStr>> =
    ::once_cell::sync::Lazy::new(|| {
        let mut map =
            ::fnv::FnvHashMap::with_capacity_and_hasher(13, ::fnv::FnvBuildHasher::default());
        map.insert(
            0,
            ::std::ffi::CStr::from_bytes_with_nul(b"Errors\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            1,
            ::std::ffi::CStr::from_bytes_with_nul(b"Expressions\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            2,
            ::std::ffi::CStr::from_bytes_with_nul(b"Functions\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            3,
            ::std::ffi::CStr::from_bytes_with_nul(b"Items\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            4,
            ::std::ffi::CStr::from_bytes_with_nul(b"Literals\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            5,
            ::std::ffi::CStr::from_bytes_with_nul(b"Statements\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            6,
            ::std::ffi::CStr::from_bytes_with_nul(b"TypedExpressions\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            7,
            ::std::ffi::CStr::from_bytes_with_nul(b"Types\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            8,
            ::std::ffi::CStr::from_bytes_with_nul(b"VariableScopes\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            9,
            ::std::ffi::CStr::from_bytes_with_nul(b"Variables\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            10,
            ::std::ffi::CStr::from_bytes_with_nul(b"VariablesInScope\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            11,
            ::std::ffi::CStr::from_bytes_with_nul(b"__Null\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map.insert(
            12,
            ::std::ffi::CStr::from_bytes_with_nul(b"__Prefix_0\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map
    });
/// A map of input `Relations`s to their name as an `&'static str`
pub static INPUT_RELIDMAP: ::once_cell::sync::Lazy<::fnv::FnvHashMap<Relations, &'static str>> =
    ::once_cell::sync::Lazy::new(|| {
        let mut map =
            ::fnv::FnvHashMap::with_capacity_and_hasher(7, ::fnv::FnvBuildHasher::default());
        map.insert(Relations::Expressions, "Expressions");
        map.insert(Relations::Functions, "Functions");
        map.insert(Relations::Items, "Items");
        map.insert(Relations::Statements, "Statements");
        map.insert(Relations::Types, "Types");
        map.insert(Relations::VariableScopes, "VariableScopes");
        map.insert(Relations::Variables, "Variables");
        map
    });
/// A map of output `Relations`s to their name as an `&'static str`
pub static OUTPUT_RELIDMAP: ::once_cell::sync::Lazy<::fnv::FnvHashMap<Relations, &'static str>> =
    ::once_cell::sync::Lazy::new(|| {
        let mut map =
            ::fnv::FnvHashMap::with_capacity_and_hasher(4, ::fnv::FnvBuildHasher::default());
        map.insert(Relations::Errors, "Errors");
        map.insert(Relations::Literals, "Literals");
        map.insert(Relations::TypedExpressions, "TypedExpressions");
        map.insert(Relations::VariablesInScope, "VariablesInScope");
        map
    });
impl TryFrom<&str> for Indexes {
    type Error = ();
    fn try_from(iname: &str) -> result::Result<Self, Self::Error> {
        match iname {
            "__Null_by_none" => Ok(Indexes::__Null_by_none),
            _ => Err(()),
        }
    }
}
impl TryFrom<IdxId> for Indexes {
    type Error = ();
    fn try_from(iid: IdxId) -> ::core::result::Result<Self, Self::Error> {
        match iid {
            0 => Ok(Indexes::__Null_by_none),
            _ => Err(()),
        }
    }
}
pub fn indexid2name(iid: IdxId) -> Option<&'static str> {
    match iid {
        0 => Some(&"__Null_by_none"),
        _ => None,
    }
}
pub fn indexid2cname(iid: IdxId) -> Option<&'static ::std::ffi::CStr> {
    IDXIDMAPC.get(&iid).copied()
}
/// A map of `Indexes` to their name as an `&'static str`
pub static IDXIDMAP: ::once_cell::sync::Lazy<::fnv::FnvHashMap<Indexes, &'static str>> =
    ::once_cell::sync::Lazy::new(|| {
        let mut map =
            ::fnv::FnvHashMap::with_capacity_and_hasher(1, ::fnv::FnvBuildHasher::default());
        map.insert(Indexes::__Null_by_none, "__Null_by_none");
        map
    });
/// A map of `IdxId`s to their name as an `&'static CStr`
pub static IDXIDMAPC: ::once_cell::sync::Lazy<::fnv::FnvHashMap<IdxId, &'static ::std::ffi::CStr>> =
    ::once_cell::sync::Lazy::new(|| {
        let mut map =
            ::fnv::FnvHashMap::with_capacity_and_hasher(1, ::fnv::FnvBuildHasher::default());
        map.insert(
            0,
            ::std::ffi::CStr::from_bytes_with_nul(b"__Null_by_none\0")
                .expect("Unreachable: A null byte was specifically inserted"),
        );
        map
    });
pub fn relval_from_record(
    rel: Relations,
    _rec: &record::Record,
) -> result::Result<DDValue, String> {
    match rel {
        Relations::Errors => Ok(Value::Errors(<Errors>::from_record(_rec)?).into_ddvalue()),
        Relations::Expressions => {
            Ok(Value::Expressions(<Expressions>::from_record(_rec)?).into_ddvalue())
        }
        Relations::Functions => {
            Ok(Value::Functions(<Functions>::from_record(_rec)?).into_ddvalue())
        }
        Relations::Items => Ok(Value::Items(<Items>::from_record(_rec)?).into_ddvalue()),
        Relations::Literals => Ok(Value::Literals(<Literals>::from_record(_rec)?).into_ddvalue()),
        Relations::Statements => {
            Ok(Value::Statements(<Statements>::from_record(_rec)?).into_ddvalue())
        }
        Relations::TypedExpressions => {
            Ok(Value::TypedExpressions(<TypedExpressions>::from_record(_rec)?).into_ddvalue())
        }
        Relations::Types => Ok(Value::Types(<Types>::from_record(_rec)?).into_ddvalue()),
        Relations::VariableScopes => {
            Ok(Value::VariableScopes(<VariableScopes>::from_record(_rec)?).into_ddvalue())
        }
        Relations::Variables => {
            Ok(Value::Variables(<Variables>::from_record(_rec)?).into_ddvalue())
        }
        Relations::VariablesInScope => {
            Ok(Value::VariablesInScope(<VariablesInScope>::from_record(_rec)?).into_ddvalue())
        }
        Relations::__Null => Ok(Value::__Tuple0__(<()>::from_record(_rec)?).into_ddvalue()),
        Relations::__Prefix_0 => Ok(
            Value::__Tuple4____Bitval64___Bitval64___Bitval64___Bitval64(
                <(u64, u64, u64, u64)>::from_record(_rec)?,
            )
            .into_ddvalue(),
        ),
    }
}
pub fn relkey_from_record(
    rel: Relations,
    _rec: &record::Record,
) -> result::Result<DDValue, String> {
    match rel {
        _ => Err(format!("relation {:?} does not have a primary key", rel)),
    }
}
pub fn idxkey_from_record(idx: Indexes, _rec: &record::Record) -> result::Result<DDValue, String> {
    match idx {
        Indexes::__Null_by_none => Ok(Value::__Tuple0__(<()>::from_record(_rec)?).into_ddvalue()),
    }
}
pub fn indexes2arrid(idx: Indexes) -> ArrId {
    match idx {
        Indexes::__Null_by_none => (11, 0),
    }
}
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Relations {
    Errors = 0,
    Expressions = 1,
    Functions = 2,
    Items = 3,
    Literals = 4,
    Statements = 5,
    TypedExpressions = 6,
    Types = 7,
    VariableScopes = 8,
    Variables = 9,
    VariablesInScope = 10,
    __Null = 11,
    __Prefix_0 = 12,
}
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub enum Indexes {
    __Null_by_none = 0,
}
