typedef Var = u64
typedef ExprId = u64
typedef FileId = u32
typedef Span = Span { start: u32, end: u32 }

typedef Location = Location {
    span: Span,
    file: FileId
}

typedef ExprKind =
    Lit { lit: Intern<LiteralVal> }
    | Variable { variable: Var }
    | Assign { variable: Var, expr_id: ExprId }

typedef TypeKind =
    Unknown
    | Str
    | Bool
    | Unit
    | Absurd
    | Error
    | Int { is_signed  : Option<bool>
          , width      : Option<u16> }

function is_int(ty: Intern<TypeKind>): bool {
    match (ty.ival()) {
        Int {} -> true,
        _      -> false
    }
}

typedef LiteralVal =
    String { str: string }
    | Boolean { boolean: bool }
    | Integer { int: u64 }

function typeof_literal(literal: Intern<LiteralVal>): Intern<TypeKind> {
    var ty = match (literal.ival()) {
        String  { } -> Str,
        Boolean { } -> Bool,
        Integer { } -> Int { None, None }
    };

    intern(ty)
}

input relation Expr(id: ExprId, kind: Intern<ExprKind>, ty: Intern<TypeKind>)

relation PropagateExprType(id: ExprId, kind: Intern<ExprKind>, ty: Intern<TypeKind>)

// Get the types out of literals
PropagateExprType(id, kind, ty) :- Expr(id, kind, _),
                                   Lit { .lit = var lit } = kind.ival(),
                                   var ty = typeof_literal(lit).
// Get the types out of assignments
PropagateExprType(id, kind, ty) :- Expr(id, kind, _),
                                   Assign { .expr_id = var expr_id } = kind.ival(),
                                   PropagateExprType(expr_id, _, ty).
// Get the types of variables by looking at their assignment
PropagateExprType(id, kind, ty) :- Expr(id, kind, _),
                                   Variable { .variable = var expr_var } = kind.ival(),
                                   PropagateExprType(_, prop_kind, ty),
                                   Assign { .variable = var prop_var } = prop_kind.ival(),
                                   expr_var == prop_var.

output relation ClampUnknownInt(id: ExprId, kind: Intern<ExprKind>, ty: Intern<TypeKind>)

// Clamp totally unknown integers to i32
ClampUnknownInt(id, kind, ty) :- PropagateExprType(id, kind, ty),
                                 Int { None, None } = ty.ival(),
                                 var ty = intern(Int { Some{true}, Some{32} }).

// Allow other types to pass through unaffected
ClampUnknownInt(id, kind, ty) :- PropagateExprType(id, kind, ty),
                                 Int { Some{}, Some{} } = ty.ival().
ClampUnknownInt(id, kind, ty) :- PropagateExprType(id, kind, ty), not ty.is_int().

// TODO: Write rust hook into `lasso` for debug repr
typedef StrT = u32

// TODO: Write rust hook into `lasso` for debug repr
typedef ItemPath = Intern<Vec<StrT>>

typedef Vis = FileLocal | Package | Exposed

typedef FuncArg = FuncArg {
    name: Var,
    kind: Intern<TypeKind>
}

typedef Function = Function {
    name: ItemPath,
    vis: Vis,
    args: Vec<FuncArg>,
    body: Intern<Stmt>,
    ret: Intern<TypeKind>
}

typedef Stmt = StmtExpr { expr: ExprId }
               | StmtItem { item: Item }
               | StmtSeq { first: Intern<Stmt>, second: Intern<Stmt> }

typedef Item = ItemFunc { func: Function } | ItemStruct {}

typedef Signature = FuncSig { args: Vec<FuncArg>, ret: Intern<TypeKind> }

function signature(item: Item): Signature {
    // FIXME: Module scoping for the path
    // TODO: Structs & stuff
    // TODO: Trait impls on stuff
    match (item) {
        ItemFunc { Function { .args = args, .ret = ret }} -> FuncSig { args, ret },
        // FIXME: Do this
        ItemStruct { } -> FuncSig { vec_empty(), intern(Unknown) }
    }
}

function corrected_signature(item: Item): Signature {
    // FIXME: Module scoping for the path
    // TODO: Structs & stuff
    // TODO: Trait impls on stuff
    match (item) {
        ItemFunc { Function { .args = old_args, .ret = ret }} -> {
            var ret = if (ret.ival() == Unknown) {
                intern(Error)
            } else {
                ret
            };

            var args = vec_with_capacity(old_args.len());
            for (arg in old_args) {
                var arg = if (arg.kind.ival() == Unknown) {
                    FuncArg { arg.name, intern(Error) }
                } else {
                    arg
                };

                args.push(arg)
            };

            FuncSig { args, ret }
        },
        // FIXME: Do this
        ItemStruct { } -> FuncSig { vec_empty(), intern(Unknown) }
    }
}

function path(item: Item): ItemPath {
    // FIXME: Module scoping for the path
    // TODO: Structs & stuff
    // TODO: Trait impls on stuff
    match (item) {
        ItemFunc { Function { .name = path }} -> path,
        // FIXME: Do this
        ItemStruct { } -> intern(vec_empty())
    }
}

function has_unknown_types(item: Item): bool {
    match (item) {
        ItemFunc { Function { .args = args, .ret = ret }} -> {
            ret.ival() == Unknown or {
                for (arg in args) {
                    if (arg.kind.ival() == Unknown) {
                        return true
                    }
                };

                false
            }
        },

        // FIXME: Do this
        ItemStruct { } -> false
    }
}

function unknown_type_errors(item: Item): Vec<string> {
    match (item) {
        ItemFunc { func } -> {
            var errors = vec_empty();
            for (arg in func.args) {
                if (arg.kind.ival() == Unknown) {
                    errors.push("Function arguments cannot be unknown")
                }
            };

            if (func.ret.ival() == Unknown) {
                errors.push("Function return types cannot be unknown")
            };

            errors
        },

        // FIXME: Do this
        ItemStruct {} -> vec_empty()
    }
}

typedef Scope = ScopeFunction { func: Intern<Function> }
                | ScopeSeq1 { parent: Intern<Scope> } 
                | ScopeSeq2 { parent: Intern<Scope> }

input relation InputItems(item: Item)

// FIXME: Error locations and structured errors, maybe hook into codespan
output relation Errors(message: string)
output relation SymbolTable(path: ItemPath, signature: Signature)

output relation Functions(func: Intern<Function>)
// Insert types with valid signatures into the symbol table
SymbolTable(path, signature), Functions(intern(func)) :-
    InputItems(item @ ItemFunc { func }),
    not item.has_unknown_types(),
    var path = item.path(),
    var signature = item.signature().
// TODO: Use FlatMap to get inner items

// Emit errors for unknown types in signatures and replace the unknown types with error types
SymbolTable(path, signature), Errors(message), Functions(intern(func)) :-
    InputItems(item @ ItemFunc { func }),
    item.has_unknown_types(),
    var message = FlatMap(item.unknown_type_errors()),
    var path = item.path(),
    var signature = item.corrected_signature().

output relation Statements(stmt: Intern<Stmt>, scope: Intern<Scope>)
Statements(stmt, intern(ScopeFunction { func })) :- Functions(func), Function { .body = var stmt } = func.ival().
Statements(stmt1, intern(ScopeSeq1 { parent })), Statements(stmt2, intern(ScopeSeq2 { parent })) :-
    Statements(stmt, parent), StmtSeq { var stmt1, var stmt2 } = stmt.ival().

