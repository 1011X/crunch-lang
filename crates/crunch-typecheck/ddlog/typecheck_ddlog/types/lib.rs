#![allow(
    path_statements,
    unused_imports,
    non_snake_case,
    non_camel_case_types,
    non_upper_case_globals,
    unused_parens,
    non_shorthand_field_patterns,
    dead_code,
    overflowing_literals,
    unreachable_patterns,
    unused_variables,
    clippy::unknown_clippy_lints,
    clippy::missing_safety_doc
)]

use num::bigint::BigInt;
use num::FromPrimitive;
use num_traits::identities::One;
use ordered_float::OrderedFloat;
use std::borrow;
use std::fmt;
use std::hash::Hash;
use std::ops::Deref;
use std::os::raw; // TODO: this is  only used by ovn.rs and should be moved there.
use std::result;

use serde::de::DeserializeOwned;
use serde::Deserialize;
use serde::Serialize;

use lazy_static::lazy_static;

use differential_datalog::ddval::*;
use differential_datalog::decl_enum_into_record;
use differential_datalog::decl_record_mutator_enum;
use differential_datalog::decl_record_mutator_struct;
use differential_datalog::decl_struct_into_record;
use differential_datalog::int::*;
use differential_datalog::program::*;
use differential_datalog::record;
use differential_datalog::record::FromRecord;
use differential_datalog::record::IntoRecord;
use differential_datalog::uint::*;

mod log;
pub use log::*;

/* FlatBuffers code generated by `flatc` */
#[cfg(feature = "flatbuf")]
mod flatbuf_generated;

/* `FromFlatBuffer`, `ToFlatBuffer`, etc, trait declarations. */
#[cfg(feature = "flatbuf")]
pub mod flatbuf;

pub trait Val:
    Default + Eq + Ord + Clone + Hash + PartialEq + PartialOrd + Serialize + DeserializeOwned + 'static
{
}

impl<T> Val for T where
    T: Default
        + Eq
        + Ord
        + Clone
        + Hash
        + PartialEq
        + PartialOrd
        + Serialize
        + DeserializeOwned
        + 'static
{
}

pub fn string_append_str(mut s1: String, s2: &str) -> String {
    s1.push_str(s2);
    s1
}

#[allow(clippy::ptr_arg)]
pub fn string_append(mut s1: String, s2: &String) -> String {
    s1.push_str(s2.as_str());
    s1
}

#[macro_export]
macro_rules! deserialize_map_from_array {
    ( $modname:ident, $ktype:ty, $vtype:ty, $kfunc:ident ) => {
        mod $modname {
            use super::*;
            use serde::de::{Deserialize, Deserializer};
            use serde::ser::Serializer;
            use std::collections::BTreeMap;

            pub fn serialize<S>(
                map: &__std::std_Map<$ktype, $vtype>,
                serializer: S,
            ) -> Result<S::Ok, S::Error>
            where
                S: Serializer,
            {
                serializer.collect_seq(map.x.values())
            }

            pub fn deserialize<'de, D>(
                deserializer: D,
            ) -> Result<__std::std_Map<$ktype, $vtype>, D::Error>
            where
                D: Deserializer<'de>,
            {
                let v = Vec::<$vtype>::deserialize(deserializer)?;
                Ok(v.into_iter().map(|item| ($kfunc(&item), item)).collect())
            }
        }
    };
}


pub use __std::*;
mod __std {
    use super::*;
    /// Rust implementation of DDlog standard library functions and types.
    extern crate num;
    
    use differential_datalog::arcval;
    use differential_datalog::record::*;
    
    use serde::de::Deserialize;
    use serde::de::Deserializer;
    use serde::ser::Serialize;
    use serde::ser::Serializer;
    use std::cmp;
    use std::collections::btree_map;
    use std::collections::btree_set;
    use std::collections::{BTreeMap, BTreeSet};
    use std::fmt;
    use std::fmt::Display;
    use std::hash::Hash;
    use std::hash::Hasher;
    use std::iter::FromIterator;
    use std::ops;
    use std::slice;
    use std::vec;
    use std::vec::Vec;
    use twox_hash::XxHash;
    
    #[cfg(feature = "flatbuf")]
    use flatbuf::{FBIter, FromFlatBuffer, ToFlatBuffer, ToFlatBufferTable, ToFlatBufferVectorElement};
    
    /* FlatBuffers runtime */
    #[cfg(feature = "flatbuf")]
    use flatbuffers as fbrt;
    
    const XX_SEED1: u64 = 0x23b691a751d0e108;
    const XX_SEED2: u64 = 0x20b09801dce5ff84;
    
    // Result
    
    /* Convert Rust result type to DDlog's std::Result. */
    pub fn res2std<T, E: Display>(res: Result<T, E>) -> std_Result<T, String> {
        match res {
            Ok(res) => std_Result::std_Ok { res },
            Err(e) => std_Result::std_Err {
                err: format!("{}", e),
            },
        }
    }
    
    pub fn std_result_unwrap_or_default<T: Default + Clone, E>(res: &std_Result<T, E>) -> T {
        match res {
            std_Result::std_Ok { res } => res.clone(),
            std_Result::std_Err { err } => T::default(),
        }
    }
    
    // Ref
    pub type std_Ref<A> = arcval::ArcVal<A>;
    
    pub fn std_ref_new<A: Clone>(x: &A) -> std_Ref<A> {
        arcval::ArcVal::from(x.clone())
    }
    
    pub fn std_deref<A: Clone>(x: &std_Ref<A>) -> &A {
        x.deref()
    }
    
    #[cfg(feature = "flatbuf")]
    impl<T, FB> FromFlatBuffer<FB> for std_Ref<T>
    where
        T: FromFlatBuffer<FB>,
    {
        fn from_flatbuf(fb: FB) -> Response<Self> {
            Ok(std_Ref::from(T::from_flatbuf(fb)?))
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'b, T> ToFlatBuffer<'b> for std_Ref<T>
    where
        T: ToFlatBuffer<'b>,
    {
        type Target = T::Target;
    
        fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
            self.deref().to_flatbuf(fbb)
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'b, T> ToFlatBufferTable<'b> for std_Ref<T>
    where
        T: ToFlatBufferTable<'b>,
    {
        type Target = T::Target;
    
        fn to_flatbuf_table(
            &self,
            fbb: &mut fbrt::FlatBufferBuilder<'b>,
        ) -> fbrt::WIPOffset<Self::Target> {
            self.deref().to_flatbuf_table(fbb)
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'b, T> ToFlatBufferVectorElement<'b> for std_Ref<T>
    where
        T: ToFlatBufferVectorElement<'b>,
    {
        type Target = T::Target;
    
        fn to_flatbuf_vector_element(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
            self.deref().to_flatbuf_vector_element(fbb)
        }
    }
    
    // Arithmetic functions
    pub fn std_pow32<T: num::One + ops::Mul + Clone>(base: &T, exp: &u32) -> T {
        num::pow::pow(base.clone(), *exp as usize)
    }
    
    // Option
    pub fn option2std<T>(x: Option<T>) -> std_Option<T> {
        match x {
            None => std_Option::std_None,
            Some(v) => std_Option::std_Some { x: v },
        }
    }
    
    pub fn std2option<T>(x: std_Option<T>) -> Option<T> {
        match x {
            std_Option::std_None => None,
            std_Option::std_Some { x } => Some(x),
        }
    }
    
    impl<T> From<Option<T>> for std_Option<T> {
        fn from(x: Option<T>) -> Self {
            option2std(x)
        }
    }
    
    // this requires Rust 1.41+
    impl<T> From<std_Option<T>> for Option<T> {
        fn from(x: std_Option<T>) -> Self {
            std2option(x)
        }
    }
    
    impl<A: record::FromRecord + serde::de::DeserializeOwned + Default> record::FromRecord
        for std_Option<A>
    {
        fn from_record(val: &record::Record) -> result::Result<Self, String> {
            match val {
                record::Record::PosStruct(constr, args) => match constr.as_ref() {
                    "std::None" if args.len() == 0 => Ok(std_Option::std_None {}),
                    "std::Some" if args.len() == 1 => Ok(std_Option::std_Some {
                        x: <A>::from_record(&args[0])?,
                    }),
                    c => result::Result::Err(format!(
                        "unknown constructor {} of type std_Option in {:?}",
                        c, *val
                    )),
                },
                record::Record::NamedStruct(constr, args) => match constr.as_ref() {
                    "std::None" => Ok(std_Option::std_None {}),
                    "std::Some" => Ok(std_Option::std_Some {
                        x: record::arg_extract::<A>(args, "x")?,
                    }),
                    c => result::Result::Err(format!(
                        "unknown constructor {} of type std_Option in {:?}",
                        c, *val
                    )),
                },
                /* `Option` encoded as an array of size 0 or 1.  This is, for instance, useful when
                 * interfacing with OVSDB. */
                record::Record::Array(kind, records) => match (records.len()) {
                    0 => Ok(std_Option::std_None {}),
                    1 => Ok(std_Option::std_Some {
                        x: A::from_record(&records[0])?,
                    }),
                    n => Err(format!(
                        "cannot deserialize std::Option from container of size {:?}",
                        n
                    )),
                },
                record::Record::Serialized(format, s) => {
                    if format == "json" {
                        serde_json::from_str(&*s).map_err(|e| format!("{}", e))
                    } else {
                        result::Result::Err(format!("unsupported serialization format '{}'", format))
                    }
                }
                v => {
                    /* Finally, assume that the record contains the inner value of a `Some`.
                     * XXX: this introduces ambiguity, as an array could represent either the inner
                     * value or an array encoding of `Option`. */
                    Ok(std_Option::std_Some {
                        x: A::from_record(&v)?,
                    })
                }
            }
        }
    }
    
    pub fn std_option_unwrap_or_default<T: Default + Clone>(opt: &std_Option<T>) -> T {
        match opt {
            std_Option::std_Some { x } => x.clone(),
            std_Option::std_None => T::default(),
        }
    }
    
    // Range
    pub fn std_range<A: Clone + Ord + ops::Add<Output = A> + PartialOrd>(
        from: &A,
        to: &A,
        step: &A,
    ) -> std_Vec<A> {
        let mut vec = std_Vec::new();
        let mut x = from.clone();
        while x <= *to {
            vec.push(x.clone());
            x = x + step.clone();
        }
        vec
    }
    
    // Vector
    
    #[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default)]
    pub struct std_Vec<T> {
        pub x: Vec<T>,
    }
    
    impl<T: Serialize> Serialize for std_Vec<T> {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            self.x.serialize(serializer)
        }
    }
    
    impl<'de, T: Deserialize<'de>> Deserialize<'de> for std_Vec<T> {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: Deserializer<'de>,
        {
            Vec::deserialize(deserializer).map(|x| std_Vec { x })
        }
    }
    
    /* This is needed so we can support for-loops over `Vec`'s
     */
    pub struct VecIter<'a, X> {
        iter: slice::Iter<'a, X>,
    }
    
    impl<'a, X> VecIter<'a, X> {
        pub fn new(vec: &'a std_Vec<X>) -> VecIter<'a, X> {
            VecIter { iter: vec.x.iter() }
        }
    }
    
    impl<'a, X> Iterator for VecIter<'a, X> {
        type Item = &'a X;
    
        fn next(&mut self) -> Option<Self::Item> {
            self.iter.next()
        }
    
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.iter.size_hint()
        }
    }
    
    impl<'a, T> std_Vec<T> {
        pub fn iter(&'a self) -> VecIter<'a, T> {
            VecIter::new(self)
        }
    }
    
    impl<T> std_Vec<T> {
        pub fn new() -> Self {
            std_Vec { x: Vec::new() }
        }
        pub fn with_capacity(capacity: usize) -> Self {
            std_Vec {
                x: Vec::with_capacity(capacity),
            }
        }
        pub fn push(&mut self, v: T) {
            self.x.push(v);
        }
    }
    
    impl<T: Clone> From<&[T]> for std_Vec<T> {
        fn from(s: &[T]) -> Self {
            std_Vec { x: Vec::from(s) }
        }
    }
    
    impl<T: Clone> From<Vec<T>> for std_Vec<T> {
        fn from(x: Vec<T>) -> Self {
            std_Vec { x }
        }
    }
    
    impl<T> Deref for std_Vec<T> {
        type Target = [T];
    
        fn deref(&self) -> &[T] {
            self.x.deref()
        }
    }
    
    impl<T: Clone> std_Vec<T> {
        pub fn extend_from_slice(&mut self, other: &[T]) {
            self.x.extend_from_slice(other);
        }
        pub fn resize(&mut self, new_len: usize, value: T) {
            self.x.resize(new_len, value);
        }
    }
    
    impl<T: FromRecord> FromRecord for std_Vec<T> {
        fn from_record(val: &Record) -> Result<Self, String> {
            Vec::from_record(val).map(|x| std_Vec { x })
        }
    }
    
    impl<T: IntoRecord> IntoRecord for std_Vec<T> {
        fn into_record(self) -> Record {
            self.x.into_record()
        }
    }
    
    impl<T: FromRecord> Mutator<std_Vec<T>> for Record {
        fn mutate(&self, vec: &mut std_Vec<T>) -> Result<(), String> {
            self.mutate(&mut vec.x)
        }
    }
    
    impl<T: Display> Display for std_Vec<T> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            let len = self.x.len();
            formatter.write_str("[")?;
            for (i, v) in self.x.iter().enumerate() {
                formatter.write_fmt(format_args!("{}", *v))?;
                if i < len - 1 {
                    formatter.write_str(",")?;
                }
            }
            formatter.write_str("]")?;
            Ok(())
        }
    }
    
    impl<T: fmt::Debug> fmt::Debug for std_Vec<T> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            let len = self.x.len();
            formatter.write_str("[")?;
            for (i, v) in self.x.iter().enumerate() {
                formatter.write_fmt(format_args!("{:?}", *v))?;
                if i < len - 1 {
                    formatter.write_str(",")?;
                }
            }
            formatter.write_str("]")?;
            Ok(())
        }
    }
    
    impl<T> IntoIterator for std_Vec<T> {
        type Item = T;
        type IntoIter = vec::IntoIter<T>;
        fn into_iter(self) -> Self::IntoIter {
            self.x.into_iter()
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'a, T, F> FromFlatBuffer<fbrt::Vector<'a, F>> for std_Vec<T>
    where
        T: Ord + FromFlatBuffer<F::Inner>,
        F: fbrt::Follow<'a> + 'a,
    {
        fn from_flatbuf(fb: fbrt::Vector<'a, F>) -> Response<Self> {
            let mut vec = std_Vec::with_capacity(fb.len());
            for x in FBIter::from_vector(fb) {
                vec.push(T::from_flatbuf(x)?);
            }
            Ok(vec)
        }
    }
    
    // For scalar types, the FlatBuffers API returns slice instead of 'Vector'.
    #[cfg(feature = "flatbuf")]
    impl<'a, T> FromFlatBuffer<&'a [T]> for std_Vec<T>
    where
        T: Clone,
    {
        fn from_flatbuf(fb: &'a [T]) -> Response<Self> {
            let mut vec = std_Vec::with_capacity(fb.len());
            vec.extend_from_slice(fb);
            Ok(vec)
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'b, T> ToFlatBuffer<'b> for std_Vec<T>
    where
        T: ToFlatBufferVectorElement<'b>,
    {
        type Target = fbrt::WIPOffset<fbrt::Vector<'b, <T::Target as fbrt::Push>::Output>>;
    
        fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
            let vec: Vec<T::Target> = self
                .iter()
                .map(|x| x.to_flatbuf_vector_element(fbb))
                .collect();
            fbb.create_vector(vec.as_slice())
        }
    }
    
    pub fn std_vec_len<X: Ord + Clone>(v: &std_Vec<X>) -> std_usize {
        v.x.len() as std_usize
    }
    
    pub fn std_vec_empty<X: Ord + Clone>() -> std_Vec<X> {
        std_Vec::new()
    }
    
    pub fn std_vec_with_length<X: Ord + Clone>(len: &std_usize, x: &X) -> std_Vec<X> {
        let mut res = std_Vec::with_capacity(*len as usize);
        res.resize(*len as usize, x.clone());
        res
    }
    
    pub fn std_vec_with_capacity<X: Ord + Clone>(len: &std_usize) -> std_Vec<X> {
        std_Vec::with_capacity(*len as usize)
    }
    
    pub fn std_vec_singleton<X: Ord + Clone>(x: &X) -> std_Vec<X> {
        std_Vec { x: vec![x.clone()] }
    }
    
    pub fn std_vec_append<X: Ord + Clone>(v: &mut std_Vec<X>, other: &std_Vec<X>) {
        v.extend_from_slice(other.x.as_slice());
    }
    
    pub fn std_vec_push<X: Ord + Clone>(v: &mut std_Vec<X>, x: &X) {
        v.push((*x).clone());
    }
    
    pub fn std_vec_push_imm<X: Ord + Clone>(v: &std_Vec<X>, x: &X) -> std_Vec<X> {
        let mut v2 = v.clone();
        v2.push((*x).clone());
        v2
    }
    
    pub fn std_vec_contains<X: Ord>(v: &std_Vec<X>, x: &X) -> bool {
        v.x.contains(x)
    }
    
    pub fn std_vec_is_empty<X: Ord>(v: &std_Vec<X>) -> bool {
        v.x.is_empty()
    }
    
    pub fn std_vec_nth<X: Ord + Clone>(v: &std_Vec<X>, n: &std_usize) -> std_Option<X> {
        option2std(v.x.get(*n as usize).cloned())
    }
    
    pub fn std_vec_to_set<X: Ord + Clone>(s: &std_Vec<X>) -> std_Set<X> {
        std_Set {
            x: s.x.iter().cloned().collect(),
        }
    }
    
    pub fn std_vec_sort<X: Ord>(v: &mut std_Vec<X>) {
        v.x.as_mut_slice().sort();
    }
    
    pub fn std_vec_sort_imm<X: Ord + Clone>(v: &std_Vec<X>) -> std_Vec<X> {
        let mut res = (*v).clone();
        res.x.sort();
        res
    }
    
    // Set
    
    #[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default)]
    pub struct std_Set<T: Ord> {
        pub x: BTreeSet<T>,
    }
    
    impl<T: Ord + Serialize> Serialize for std_Set<T> {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            self.x.serialize(serializer)
        }
    }
    
    impl<'de, T: Ord + Deserialize<'de>> Deserialize<'de> for std_Set<T> {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: Deserializer<'de>,
        {
            BTreeSet::deserialize(deserializer).map(|x| std_Set { x })
        }
    }
    
    /* This is needed so we can support for-loops over `Set`'s
     */
    pub struct SetIter<'a, X> {
        iter: btree_set::Iter<'a, X>,
    }
    
    impl<'a, X: Ord> SetIter<'a, X> {
        pub fn new(set: &'a std_Set<X>) -> SetIter<'a, X> {
            SetIter { iter: set.x.iter() }
        }
    }
    
    impl<'a, X> Iterator for SetIter<'a, X> {
        type Item = &'a X;
    
        fn next(&mut self) -> Option<Self::Item> {
            self.iter.next()
        }
    
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.iter.size_hint()
        }
    }
    
    impl<'a, T: Ord> std_Set<T> {
        pub fn iter(&'a self) -> SetIter<'a, T> {
            SetIter::new(self)
        }
    }
    
    impl<T: Ord> std_Set<T> {
        pub fn new() -> Self {
            std_Set { x: BTreeSet::new() }
        }
        pub fn insert(&mut self, v: T) {
            self.x.insert(v);
        }
    }
    
    impl<T: FromRecord + Ord> FromRecord for std_Set<T> {
        fn from_record(val: &Record) -> Result<Self, String> {
            BTreeSet::from_record(val).map(|x| std_Set { x })
        }
    }
    
    impl<T: IntoRecord + Ord> IntoRecord for std_Set<T> {
        fn into_record(self) -> Record {
            self.x.into_record()
        }
    }
    
    impl<T: FromRecord + Ord> Mutator<std_Set<T>> for Record {
        fn mutate(&self, set: &mut std_Set<T>) -> Result<(), String> {
            self.mutate(&mut set.x)
        }
    }
    
    impl<T: Ord> IntoIterator for std_Set<T> {
        type Item = T;
        type IntoIter = btree_set::IntoIter<T>;
        fn into_iter(self) -> Self::IntoIter {
            self.x.into_iter()
        }
    }
    
    impl<T: Ord> FromIterator<T> for std_Set<T> {
        fn from_iter<I>(iter: I) -> Self
        where
            I: IntoIterator<Item = T>,
        {
            std_Set {
                x: BTreeSet::from_iter(iter),
            }
        }
    }
    
    impl<T: Display + Ord> Display for std_Set<T> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            let len = self.x.len();
            formatter.write_str("[")?;
            for (i, v) in self.x.iter().enumerate() {
                formatter.write_fmt(format_args!("{}", *v))?;
                if i < len - 1 {
                    formatter.write_str(",")?;
                }
            }
            formatter.write_str("]")?;
            Ok(())
        }
    }
    
    impl<T: fmt::Debug + Ord> fmt::Debug for std_Set<T> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            let len = self.x.len();
            formatter.write_str("[")?;
            for (i, v) in self.x.iter().enumerate() {
                formatter.write_fmt(format_args!("{:?}", *v))?;
                if i < len - 1 {
                    formatter.write_str(",")?;
                }
            }
            formatter.write_str("]")?;
            Ok(())
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'a, T, F> FromFlatBuffer<fbrt::Vector<'a, F>> for std_Set<T>
    where
        T: Ord + FromFlatBuffer<F::Inner>,
        F: fbrt::Follow<'a> + 'a,
    {
        fn from_flatbuf(fb: fbrt::Vector<'a, F>) -> Response<Self> {
            let mut set = std_Set::new();
            for x in FBIter::from_vector(fb) {
                set.insert(T::from_flatbuf(x)?);
            }
            Ok(set)
        }
    }
    
    // For scalar types, the FlatBuffers API returns slice instead of 'Vector'.
    #[cfg(feature = "flatbuf")]
    impl<'a, T> FromFlatBuffer<&'a [T]> for std_Set<T>
    where
        T: Ord + Clone,
    {
        fn from_flatbuf(fb: &'a [T]) -> Response<Self> {
            let mut set = std_Set::new();
            for x in fb.iter() {
                set.insert(x.clone());
            }
            Ok(set)
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'b, T> ToFlatBuffer<'b> for std_Set<T>
    where
        T: Ord + ToFlatBufferVectorElement<'b>,
    {
        type Target = fbrt::WIPOffset<fbrt::Vector<'b, <T::Target as fbrt::Push>::Output>>;
    
        fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
            let vec: Vec<T::Target> = self
                .iter()
                .map(|x| x.to_flatbuf_vector_element(fbb))
                .collect();
            fbb.create_vector(vec.as_slice())
        }
    }
    
    pub fn std_set_size<X: Ord + Clone>(s: &std_Set<X>) -> std_usize {
        s.x.len() as std_usize
    }
    
    pub fn std_set_empty<X: Ord + Clone>() -> std_Set<X> {
        std_Set::new()
    }
    
    pub fn std_set_singleton<X: Ord + Clone>(v: &X) -> std_Set<X> {
        let mut s = std_Set::new();
        s.insert(v.clone());
        s
    }
    
    pub fn std_set_insert<X: Ord + Clone>(s: &mut std_Set<X>, v: &X) {
        s.x.insert((*v).clone());
    }
    
    pub fn std_set_insert_imm<X: Ord + Clone>(s: &std_Set<X>, v: &X) -> std_Set<X> {
        let mut s2 = s.clone();
        s2.insert((*v).clone());
        s2
    }
    
    pub fn std_set_contains<X: Ord>(s: &std_Set<X>, v: &X) -> bool {
        s.x.contains(v)
    }
    
    pub fn std_set_is_empty<X: Ord>(s: &std_Set<X>) -> bool {
        s.x.is_empty()
    }
    
    pub fn std_set_nth<X: Ord + Clone>(s: &std_Set<X>, n: &std_usize) -> std_Option<X> {
        option2std(s.x.iter().nth(*n as usize).cloned())
    }
    
    pub fn std_set_to_vec<X: Ord + Clone>(s: &std_Set<X>) -> std_Vec<X> {
        std_Vec {
            x: s.x.iter().cloned().collect(),
        }
    }
    
    pub fn std_set_union<X: Ord + Clone>(s1: &std_Set<X>, s2: &std_Set<X>) -> std_Set<X> {
        let mut s = s1.clone();
        s.x.append(&mut s2.x.clone());
        s
    }
    
    pub fn std_set_unions<X: Ord + Clone>(sets: &std_Vec<std_Set<X>>) -> std_Set<X> {
        let mut s = BTreeSet::new();
        for si in sets.x.iter() {
            s.append(&mut si.x.clone());
        }
        std_Set { x: s }
    }
    
    pub fn std_set_intersection<X: Ord + Clone>(s1: &std_Set<X>, s2: &std_Set<X>) -> std_Set<X> {
        std_Set {
            x: s1.x.intersection(&s2.x).cloned().collect(),
        }
    }
    
    pub fn std_set_difference<X: Ord + Clone>(s1: &std_Set<X>, s2: &std_Set<X>) -> std_Set<X> {
        std_Set {
            x: s1.x.difference(&s2.x).cloned().collect(),
        }
    }
    
    // Map
    
    #[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default)]
    pub struct std_Map<K: Ord, V> {
        pub x: BTreeMap<K, V>,
    }
    
    impl<K: Ord + Serialize, V: Serialize> Serialize for std_Map<K, V> {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            self.x.serialize(serializer)
        }
    }
    
    impl<'de, K: Ord + Deserialize<'de>, V: Deserialize<'de>> Deserialize<'de> for std_Map<K, V> {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: Deserializer<'de>,
        {
            BTreeMap::deserialize(deserializer).map(|x| std_Map { x })
        }
    }
    
    /* This is needed so we can support for-loops over `Map`'s
     */
    pub struct MapIter<'a, K, V> {
        iter: btree_map::Iter<'a, K, V>,
    }
    
    impl<'a, K: Ord, V> MapIter<'a, K, V> {
        pub fn new(map: &'a std_Map<K, V>) -> MapIter<'a, K, V> {
            MapIter { iter: map.x.iter() }
        }
    }
    
    impl<'a, K: Clone, V: Clone> Iterator for MapIter<'a, K, V> {
        type Item = (K, V);
    
        fn next(&mut self) -> Option<Self::Item> {
            self.iter.next().map(|(k, v)| (k.clone(), v.clone()))
        }
    
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.iter.size_hint()
        }
    }
    
    impl<'a, K: Ord, V> std_Map<K, V> {
        pub fn iter(&'a self) -> MapIter<'a, K, V> {
            MapIter::new(self)
        }
    }
    
    impl<K: Ord, V> std_Map<K, V> {
        pub fn new() -> Self {
            std_Map { x: BTreeMap::new() }
        }
        pub fn insert(&mut self, k: K, v: V) {
            self.x.insert(k, v);
        }
    }
    
    impl<K: FromRecord + Ord, V: FromRecord> FromRecord for std_Map<K, V> {
        fn from_record(val: &Record) -> Result<Self, String> {
            BTreeMap::from_record(val).map(|x| std_Map { x })
        }
    }
    
    impl<K: IntoRecord + Ord, V: IntoRecord> IntoRecord for std_Map<K, V> {
        fn into_record(self) -> Record {
            self.x.into_record()
        }
    }
    
    impl<K: FromRecord + Ord, V: FromRecord + PartialEq> Mutator<std_Map<K, V>> for Record {
        fn mutate(&self, map: &mut std_Map<K, V>) -> Result<(), String> {
            self.mutate(&mut map.x)
        }
    }
    
    impl<K: Ord, V> IntoIterator for std_Map<K, V> {
        type Item = (K, V);
        type IntoIter = btree_map::IntoIter<K, V>;
        fn into_iter(self) -> Self::IntoIter {
            self.x.into_iter()
        }
    }
    
    impl<K: Ord, V> FromIterator<(K, V)> for std_Map<K, V> {
        fn from_iter<I>(iter: I) -> Self
        where
            I: IntoIterator<Item = (K, V)>,
        {
            std_Map {
                x: BTreeMap::from_iter(iter),
            }
        }
    }
    
    impl<K: Display + Ord, V: Display> Display for std_Map<K, V> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            let len = self.x.len();
            formatter.write_str("[")?;
            for (i, (k, v)) in self.x.iter().enumerate() {
                formatter.write_fmt(format_args!("({},{})", *k, *v))?;
                if i < len - 1 {
                    formatter.write_str(",")?;
                }
            }
            formatter.write_str("]")?;
            Ok(())
        }
    }
    
    impl<K: fmt::Debug + Ord, V: fmt::Debug> fmt::Debug for std_Map<K, V> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            let len = self.x.len();
            formatter.write_str("[")?;
            for (i, (k, v)) in self.x.iter().enumerate() {
                formatter.write_fmt(format_args!("({:?},{:?})", *k, *v))?;
                if i < len - 1 {
                    formatter.write_str(",")?;
                }
            }
            formatter.write_str("]")?;
            Ok(())
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'a, K, V, F> FromFlatBuffer<fbrt::Vector<'a, F>> for std_Map<K, V>
    where
        F: fbrt::Follow<'a> + 'a,
        K: Ord,
        (K, V): FromFlatBuffer<F::Inner>,
    {
        fn from_flatbuf(fb: fbrt::Vector<'a, F>) -> Response<Self> {
            let mut m = std_Map::new();
            for x in FBIter::from_vector(fb) {
                let (k, v) = <(K, V)>::from_flatbuf(x)?;
                m.insert(k, v);
            }
            Ok(m)
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'b, K, V, T> ToFlatBuffer<'b> for std_Map<K, V>
    where
        K: Ord + Clone,
        V: Clone,
        (K, V): ToFlatBufferVectorElement<'b, Target = T>,
        T: 'b + fbrt::Push + Copy,
    {
        type Target = fbrt::WIPOffset<fbrt::Vector<'b, <T as fbrt::Push>::Output>>;
    
        fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
            let vec: Vec<<(K, V) as ToFlatBufferVectorElement<'b>>::Target> = self
                .iter()
                .map(|(k, v)| (k, v).to_flatbuf_vector_element(fbb))
                .collect();
            fbb.create_vector(vec.as_slice())
        }
    }
    
    pub fn std_map_size<K: Ord, V>(m: &std_Map<K, V>) -> std_usize {
        m.x.len() as std_usize
    }
    
    pub fn std_map_empty<K: Ord + Clone, V: Clone>() -> std_Map<K, V> {
        std_Map::new()
    }
    
    pub fn std_map_singleton<K: Ord + Clone, V: Clone>(k: &K, v: &V) -> std_Map<K, V> {
        let mut m = std_Map::new();
        m.insert(k.clone(), v.clone());
        m
    }
    
    pub fn std_map_insert<K: Ord + Clone, V: Clone>(m: &mut std_Map<K, V>, k: &K, v: &V) {
        m.x.insert((*k).clone(), (*v).clone());
    }
    
    pub fn std_map_remove<K: Ord + Clone, V: Clone>(m: &mut std_Map<K, V>, k: &K) {
        m.x.remove(k);
    }
    
    pub fn std_map_insert_imm<K: Ord + Clone, V: Clone>(
        m: &std_Map<K, V>,
        k: &K,
        v: &V,
    ) -> std_Map<K, V> {
        let mut m2 = m.clone();
        m2.insert((*k).clone(), (*v).clone());
        m2
    }
    
    pub fn std_map_get<K: Ord, V: Clone>(m: &std_Map<K, V>, k: &K) -> std_Option<V> {
        option2std(m.x.get(k).cloned())
    }
    
    pub fn std_map_contains_key<K: Ord, V: Clone>(s: &std_Map<K, V>, k: &K) -> bool {
        s.x.contains_key(k)
    }
    
    pub fn std_map_is_empty<K: Ord, V: Clone>(m: &std_Map<K, V>) -> bool {
        m.x.is_empty()
    }
    
    pub fn std_map_union<K: Ord + Clone, V: Clone>(
        m1: &std_Map<K, V>,
        m2: &std_Map<K, V>,
    ) -> std_Map<K, V> {
        let mut m = m1.clone();
        m.x.append(&mut m2.x.clone());
        m
    }
    
    // strings
    
    pub fn std___builtin_2string<T: Display>(x: &T) -> String {
        format!("{}", *x).to_string()
    }
    
    pub fn std_hex<T: fmt::LowerHex>(x: &T) -> String {
        format!("{:x}", *x).to_string()
    }
    
    pub fn std_parse_dec_u64(s: &String) -> std_Option<u64> {
        option2std(s.parse::<u64>().ok())
    }
    
    pub fn std_parse_dec_i64(s: &String) -> std_Option<i64> {
        option2std(s.parse::<i64>().ok())
    }
    
    pub fn std_string_join(strings: &std_Vec<String>, sep: &String) -> String {
        strings.x.join(sep.as_str())
    }
    
    pub fn std_string_split(s: &String, sep: &String) -> std_Vec<String> {
        std_Vec {
            x: s.split(sep).map(|x| x.to_owned()).collect(),
        }
    }
    
    pub fn std_string_contains(s1: &String, s2: &String) -> bool {
        s1.contains(s2.as_str())
    }
    
    pub fn std_string_substr(s: &String, start: &std_usize, end: &std_usize) -> String {
        let len = s.len();
        let from = cmp::min(*start as usize, len);
        let to = cmp::max(from, cmp::min(*end as usize, len));
        s[from..to].to_string()
    }
    
    pub fn std_string_replace(s: &String, from: &String, to: &String) -> String {
        s.replace(from, to)
    }
    
    pub fn std_string_starts_with(s: &String, prefix: &String) -> bool {
        s.starts_with(prefix)
    }
    
    pub fn std_string_ends_with(s: &String, suffix: &String) -> bool {
        s.ends_with(suffix)
    }
    
    pub fn std_string_trim(s: &String) -> String {
        s.trim().to_string()
    }
    
    pub fn std_string_len(s: &String) -> std_usize {
        s.len() as std_usize
    }
    
    pub fn std_string_to_bytes(s: &String) -> std_Vec<u8> {
        std_Vec::from(s.as_bytes())
    }
    
    pub fn std_str_to_lower(s: &String) -> String {
        s.to_lowercase()
    }
    
    pub fn std_string_to_lowercase(s: &String) -> String {
        s.to_lowercase()
    }
    
    pub fn std_string_to_uppercase(s: &String) -> String {
        s.to_uppercase()
    }
    
    pub fn std_string_reverse(s: &String) -> String {
        s.chars().rev().collect()
    }
    
    // Hashing
    
    pub fn std_hash64<T: Hash>(x: &T) -> u64 {
        let mut hasher = XxHash::with_seed(XX_SEED1);
        x.hash(&mut hasher);
        hasher.finish()
    }
    
    pub fn std_hash128<T: Hash>(x: &T) -> u128 {
        let mut hasher = XxHash::with_seed(XX_SEED1);
        x.hash(&mut hasher);
        let w1 = hasher.finish();
        let mut hasher = XxHash::with_seed(XX_SEED2);
        x.hash(&mut hasher);
        let w2 = hasher.finish();
        ((w1 as u128) << 64) | (w2 as u128)
    }
    
    pub type ProjectFunc<X> = std::rc::Rc<dyn Fn(&DDValue) -> X>;
    
    /*
     * Group type (used in aggregation operators)
     */
    pub struct std_Group<'a, K, V> {
        /* TODO: remove "pub" */
        pub key: &'a K,
        pub group: &'a [(&'a DDValue, Weight)],
        pub project: ProjectFunc<V>,
    }
    
    /* This is needed so we can support for-loops over `Group`'s
     */
    pub struct GroupIter<'a, V> {
        iter: slice::Iter<'a, (&'a DDValue, Weight)>,
        project: ProjectFunc<V>,
    }
    
    impl<'a, V> GroupIter<'a, V> {
        pub fn new<K>(grp: &std_Group<'a, K, V>) -> GroupIter<'a, V> {
            GroupIter {
                iter: grp.group.iter(),
                project: grp.project.clone(),
            }
        }
    }
    
    impl<'a, V> Iterator for GroupIter<'a, V> {
        type Item = V;
    
        fn next(&mut self) -> Option<Self::Item> {
            match self.iter.next() {
                None => None,
                Some((x, _)) => Some((self.project)(x)),
            }
        }
    
        fn size_hint(&self) -> (usize, Option<usize>) {
            self.iter.size_hint()
        }
    }
    
    impl<'a, K: Clone, V> std_Group<'a, K, V> {
        fn key(&self) -> K {
            self.key.clone()
        }
    }
    
    impl<'a, K, V> std_Group<'a, K, V> {
        pub fn new(
            key: &'a K,
            group: &'a [(&'a DDValue, Weight)],
            project: ProjectFunc<V>,
        ) -> std_Group<'a, K, V> {
            std_Group {
                key,
                group,
                project,
            }
        }
    
        fn size(&self) -> std_usize {
            self.group.len() as std_usize
        }
    
        fn first(&'a self) -> V {
            (self.project)(self.group[0].0)
        }
    
        fn nth_unchecked(&'a self, n: std_usize) -> V {
            (self.project)(self.group[n as usize].0)
        }
    
        pub fn iter(&'a self) -> GroupIter<'a, V> {
            GroupIter::new(self)
        }
    }
    
    impl<'a, K, V> std_Group<'a, K, V> {
        fn nth(&'a self, n: std_usize) -> std_Option<V> {
            if self.size() > n {
                std_Option::std_Some {
                    x: (self.project)(self.group[n as usize].0),
                }
            } else {
                std_Option::std_None
            }
        }
    }
    
    pub fn std_group_key<K: Clone, V>(g: &std_Group<K, V>) -> K {
        g.key()
    }
    
    /*
     * Standard aggregation functions
     */
    pub fn std_group_count<K, V>(g: &std_Group<K, V>) -> std_usize {
        g.size()
    }
    
    pub fn std_group_first<K, V>(g: &std_Group<K, V>) -> V {
        g.first()
    }
    
    pub fn std_group_nth<K, V>(g: &std_Group<K, V>, n: &std_usize) -> std_Option<V> {
        g.nth(*n)
    }
    
    pub fn std_group_to_set<K, V: Ord + Clone>(g: &std_Group<K, V>) -> std_Set<V> {
        let mut res = std_Set::new();
        for v in g.iter() {
            std_set_insert(&mut res, &v);
        }
        res
    }
    
    pub fn std_group_set_unions<K, V: Ord + Clone>(g: &std_Group<K, std_Set<V>>) -> std_Set<V> {
        let mut res = std_Set::new();
        for gr in g.iter() {
            for v in gr.iter() {
                std_set_insert(&mut res, v);
            }
        }
        res
    }
    
    pub fn std_group_setref_unions<K, V: Ord + Clone>(
        g: &std_Group<K, std_Ref<std_Set<V>>>,
    ) -> std_Ref<std_Set<V>> {
        if g.size() == 1 {
            g.first()
        } else {
            let mut res: std_Ref<std_Set<V>> = std_ref_new(&std_Set::new());
            {
                let mut rres = std_Ref::get_mut(&mut res).unwrap();
                for gr in g.iter() {
                    for v in gr.iter() {
                        std_set_insert(&mut rres, &v);
                    }
                }
            }
            res
        }
    }
    
    pub fn std_group_to_vec<K, V: Ord + Clone>(g: &std_Group<K, V>) -> std_Vec<V> {
        let mut res = std_Vec::with_capacity(g.size() as usize);
        for v in g.iter() {
            std_vec_push(&mut res, &v);
        }
        res
    }
    
    pub fn std_group_to_map<K1, K2: Ord + Clone, V: Clone>(
        g: &std_Group<K1, (K2, V)>,
    ) -> std_Map<K2, V> {
        let mut res = std_Map::new();
        for (k, v) in g.iter() {
            std_map_insert(&mut res, &k, &v);
        }
        res
    }
    
    pub fn std_group_to_setmap<K1, K2: Ord + Clone, V: Clone + Ord>(
        g: &std_Group<K1, (K2, V)>,
    ) -> std_Map<K2, std_Set<V>> {
        let mut res = std_Map::new();
        for (k, v) in g.iter() {
            match res.x.entry(k) {
                btree_map::Entry::Vacant(ve) => {
                    ve.insert(std_set_singleton(&v));
                }
                btree_map::Entry::Occupied(mut oe) => {
                    oe.get_mut().insert(v);
                }
            }
        }
        res
    }
    
    pub fn std_group_min<K, V: Ord>(g: &std_Group<K, V>) -> V {
        g.iter().min().unwrap()
    }
    
    pub fn std_group_max<K, V: Ord>(g: &std_Group<K, V>) -> V {
        g.iter().max().unwrap()
    }
    
    pub fn std_group_sum<K, V: ops::Add<Output = V>>(g: &std_Group<K, V>) -> V {
        let mut res = std_group_first(g);
        for v in g.iter().skip(1) {
            res = res + v;
        }
        res
    }
    
    /* Tuples */
    #[derive(Copy, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
    pub struct tuple0;
    
    impl FromRecord for tuple0 {
        fn from_record(val: &Record) -> Result<Self, String> {
            <()>::from_record(val).map(|_| tuple0)
        }
    }
    
    impl IntoRecord for tuple0 {
        fn into_record(self) -> Record {
            ().into_record()
        }
    }
    
    macro_rules! decl_tuple {
        ( $name:ident, $( $t:tt ),+ ) => {
            #[derive(Default, Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize, Debug)]
            pub struct $name< $($t),* >($(pub $t),*);
            impl <$($t: FromRecord),*> FromRecord for $name<$($t),*> {
                fn from_record(val: &Record) -> Result<Self, String> {
                    <($($t),*)>::from_record(val).map(|($($t),*)|$name($($t),*))
                }
            }
    
            impl <$($t: IntoRecord),*> IntoRecord for $name<$($t),*> {
                fn into_record(self) -> Record {
                    let $name($($t),*) = self;
                    Record::Tuple(vec![$($t.into_record()),*])
                }
            }
    
            impl <$($t: FromRecord),*> Mutator<$name<$($t),*>> for Record {
                fn mutate(&self, x: &mut $name<$($t),*>) -> Result<(), String> {
                    *x = <$name<$($t),*>>::from_record(self)?;
                    Ok(())
                }
            }
        };
    }
    
    decl_tuple!(tuple2, T1, T2);
    decl_tuple!(tuple3, T1, T2, T3);
    decl_tuple!(tuple4, T1, T2, T3, T4);
    decl_tuple!(tuple5, T1, T2, T3, T4, T5);
    decl_tuple!(tuple6, T1, T2, T3, T4, T5, T6);
    decl_tuple!(tuple7, T1, T2, T3, T4, T5, T6, T7);
    decl_tuple!(tuple8, T1, T2, T3, T4, T5, T6, T7, T8);
    decl_tuple!(tuple9, T1, T2, T3, T4, T5, T6, T7, T8, T9);
    decl_tuple!(tuple10, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10);
    decl_tuple!(tuple11, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11);
    decl_tuple!(tuple12, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12);
    decl_tuple!(tuple13, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13);
    decl_tuple!(tuple14, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14);
    decl_tuple!(tuple15, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15);
    decl_tuple!(tuple16, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16);
    decl_tuple!(tuple17, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17);
    decl_tuple!(
        tuple18, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18
    );
    decl_tuple!(
        tuple19, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19
    );
    decl_tuple!(
        tuple20, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,
        T20
    );
    decl_tuple!(
        tuple21, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,
        T20, T21
    );
    decl_tuple!(
        tuple22, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,
        T20, T21, T22
    );
    decl_tuple!(
        tuple23, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,
        T20, T21, T22, T23
    );
    decl_tuple!(
        tuple24, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,
        T20, T21, T22, T23, T24
    );
    decl_tuple!(
        tuple25, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,
        T20, T21, T22, T23, T24, T25
    );
    decl_tuple!(
        tuple26, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,
        T20, T21, T22, T23, T24, T25, T26
    );
    decl_tuple!(
        tuple27, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,
        T20, T21, T22, T23, T24, T25, T26, T27
    );
    decl_tuple!(
        tuple28, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,
        T20, T21, T22, T23, T24, T25, T26, T27, T28
    );
    decl_tuple!(
        tuple29, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,
        T20, T21, T22, T23, T24, T25, T26, T27, T28, T29
    );
    decl_tuple!(
        tuple30, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19,
        T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30
    );
    
    // Endianness
    pub fn std_ntohl(x: &u32) -> u32 {
        u32::from_be(*x)
    }
    
    pub fn std_ntohs(x: &u16) -> u16 {
        u16::from_be(*x)
    }
    
    pub fn std_htonl(x: &u32) -> u32 {
        u32::to_be(*x)
    }
    
    pub fn std_htons(x: &u16) -> u16 {
        u16::to_be(*x)
    }
}
pub use __internment::*;
mod __internment {
    use super::*;
    use arc_interner;
    use differential_datalog::record;
    use differential_datalog::record::*;
    use serde;
    use std::cmp;
    use std::fmt;
    
    #[cfg(feature = "flatbuf")]
    use flatbuf::{FromFlatBuffer, ToFlatBuffer, ToFlatBufferTable, ToFlatBufferVectorElement};
    
    /* `flatc`-generated declarations re-exported by `flatbuf.rs` */
    #[cfg(feature = "flatbuf")]
    use flatbuf::fb;
    
    /* FlatBuffers runtime */
    #[cfg(feature = "flatbuf")]
    use flatbuffers as fbrt;
    
    #[derive(Default, Eq, PartialEq, Clone, Hash)]
    pub struct internment_Intern<A>
    where
        A: Eq + Send + Sync + Hash + 'static,
    {
        intern: arc_interner::ArcIntern<A>,
    }
    
    impl<A: Eq + Send + Sync + Hash + 'static> PartialOrd for internment_Intern<A> {
        fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
            let sptr = self.as_ref() as *const A as usize;
            let optr = other.as_ref() as *const A as usize;
            sptr.partial_cmp(&optr)
        }
    }
    
    impl<A: Eq + Send + Sync + Hash + 'static> Ord for internment_Intern<A> {
        fn cmp(&self, other: &Self) -> std::cmp::Ordering {
            let sptr = self.as_ref() as *const A as usize;
            let optr = other.as_ref() as *const A as usize;
            sptr.cmp(&optr)
        }
    }
    
    impl<A: Eq + Send + Sync + Hash + 'static> Deref for internment_Intern<A> {
        type Target = A;
    
        fn deref(&self) -> &Self::Target {
            self.intern.deref()
        }
    }
    
    impl<A: Eq + Hash + Send + Sync + 'static> internment_Intern<A> {
        pub fn new(x: A) -> internment_Intern<A> {
            internment_Intern {
                intern: arc_interner::ArcIntern::new(x),
            }
        }
        pub fn as_ref(&self) -> &A {
            self.intern.as_ref()
        }
    }
    
    pub fn internment_intern<A: Eq + Hash + Send + Sync + Clone + 'static>(
        x: &A,
    ) -> internment_Intern<A> {
        internment_Intern::new(x.clone())
    }
    
    pub fn internment_ival<A: Eq + Hash + Send + Sync + Clone>(x: &internment_Intern<A>) -> &A {
        x.intern.as_ref()
    }
    
    /*pub fn intern_istring_ord(s: &intern_istring) -> u32 {
        s.x
    }*/
    
    impl<A: fmt::Display + Eq + Hash + Send + Sync + Clone> fmt::Display for internment_Intern<A> {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            fmt::Display::fmt(self.as_ref(), f)
            //record::format_ddlog_str(&intern_istring_str(self), f)
        }
    }
    
    impl<A: fmt::Debug + Eq + Hash + Send + Sync + Clone> fmt::Debug for internment_Intern<A> {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            fmt::Debug::fmt(self.as_ref(), f)
            //record::format_ddlog_str(&intern_istring_str(self), f)
        }
    }
    
    impl<A: Serialize + Eq + Hash + Send + Sync + Clone> serde::Serialize for internment_Intern<A> {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            self.as_ref().serialize(serializer)
        }
    }
    
    impl<'de, A: Deserialize<'de> + Eq + Hash + Send + Sync + 'static> serde::Deserialize<'de>
        for internment_Intern<A>
    {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            A::deserialize(deserializer).map(|s| internment_Intern::new(s))
        }
    }
    
    impl<A: FromRecord + Eq + Hash + Send + Sync + 'static> FromRecord for internment_Intern<A> {
        fn from_record(val: &Record) -> Result<Self, String> {
            A::from_record(val).map(|x| internment_Intern::new(x))
        }
    }
    
    impl<A: IntoRecord + Eq + Hash + Send + Sync + Clone> IntoRecord for internment_Intern<A> {
        fn into_record(self) -> Record {
            internment_ival(&self).clone().into_record()
        }
    }
    
    impl<A> Mutator<internment_Intern<A>> for Record
    where
        A: Clone + Eq + Send + Sync + Hash,
        Record: Mutator<A>,
    {
        fn mutate(&self, x: &mut internment_Intern<A>) -> Result<(), String> {
            let mut v = internment_ival(x).clone();
            self.mutate(&mut v)?;
            *x = internment_intern(&v);
            Ok(())
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<A, FB> FromFlatBuffer<FB> for internment_Intern<A>
    where
        A: Eq + Hash + Send + Sync + 'static,
        A: FromFlatBuffer<FB>,
    {
        fn from_flatbuf(fb: FB) -> Response<Self> {
            Ok(internment_Intern::new(A::from_flatbuf(fb)?))
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'b, A, T> ToFlatBuffer<'b> for internment_Intern<A>
    where
        T: 'b,
        A: Eq + Send + Sync + Hash + ToFlatBuffer<'b, Target = T>,
    {
        type Target = T;
    
        fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
            self.as_ref().to_flatbuf(fbb)
        }
    }
    
    /*#[cfg(feature = "flatbuf")]
    impl<'a> FromFlatBuffer<fb::__String<'a>> for intern_istring {
        fn from_flatbuf(v: fb::__String<'a>) -> Response<Self> {
            Ok(intern_string_intern(&String::from_flatbuf(v)?))
        }
    }*/
    
    #[cfg(feature = "flatbuf")]
    impl<'b, A, T> ToFlatBufferTable<'b> for internment_Intern<A>
    where
        T: 'b,
        A: Eq + Send + Sync + Hash + ToFlatBufferTable<'b, Target = T>,
    {
        type Target = T;
        fn to_flatbuf_table(
            &self,
            fbb: &mut fbrt::FlatBufferBuilder<'b>,
        ) -> fbrt::WIPOffset<Self::Target> {
            self.as_ref().to_flatbuf_table(fbb)
        }
    }
    
    #[cfg(feature = "flatbuf")]
    impl<'b, A, T> ToFlatBufferVectorElement<'b> for internment_Intern<A>
    where
        T: 'b + fbrt::Push + Copy,
        A: Eq + Send + Sync + Hash + ToFlatBufferVectorElement<'b, Target = T>,
    {
        type Target = T;
    
        fn to_flatbuf_vector_element(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {
            self.as_ref().to_flatbuf_vector_element(fbb)
        }
    }
    
    pub fn internment_istring_join(strings: &std_Vec<internment_istring>, sep: &String) -> String {
        strings
            .x
            .iter()
            .map(|s| s.as_ref())
            .cloned()
            .collect::<Vec<String>>()
            .join(sep.as_str())
    }
    
    pub fn internment_istring_split(s: &internment_istring, sep: &String) -> std_Vec<String> {
        std_Vec {
            x: s.as_ref().split(sep).map(|x| x.to_owned()).collect(),
        }
    }
    
    pub fn internment_istring_contains(s1: &internment_istring, s2: &String) -> bool {
        s1.as_ref().contains(s2.as_str())
    }
    
    pub fn internment_istring_substr(
        s: &internment_istring,
        start: &std_usize,
        end: &std_usize,
    ) -> String {
        let len = s.as_ref().len();
        let from = cmp::min(*start as usize, len);
        let to = cmp::max(from, cmp::min(*end as usize, len));
        s.as_ref()[from..to].to_string()
    }
    
    pub fn internment_istring_replace(s: &internment_istring, from: &String, to: &String) -> String {
        s.as_ref().replace(from, to)
    }
    
    pub fn internment_istring_starts_with(s: &internment_istring, prefix: &String) -> bool {
        s.as_ref().starts_with(prefix)
    }
    
    pub fn internment_istring_ends_with(s: &internment_istring, suffix: &String) -> bool {
        s.as_ref().ends_with(suffix)
    }
    
    pub fn internment_istring_trim(s: &internment_istring) -> String {
        s.as_ref().trim().to_string()
    }
    
    pub fn internment_istring_len(s: &internment_istring) -> std_usize {
        s.as_ref().len() as std_usize
    }
    
    pub fn internment_istring_to_bytes(s: &internment_istring) -> std_Vec<u8> {
        std_Vec::from(s.as_ref().as_bytes())
    }
    
    pub fn internment_istring_to_lowercase(s: &internment_istring) -> String {
        s.as_ref().to_lowercase()
    }
    
    pub fn internment_istring_to_uppercase(s: &internment_istring) -> String {
        s.as_ref().to_uppercase()
    }
    
    pub fn internment_istring_reverse(s: &internment_istring) -> String {
        s.as_ref().chars().rev().collect()
    }
}
pub use __debug::*;
mod __debug {
    use super::*;
    use std::fmt;
    use std::fs::OpenOptions;
    use std::io::Write;
    use std::string::ToString;
    
    pub fn debug_debug_event<T1: ToString, A1: Clone + IntoRecord, A2: Clone + IntoRecord>(
        operator_id: &(u32, u32, u32),
        w: &std_DDWeight,
        ts: &T1,
        operator_type: &String,
        input1: &A1,
        out: &A2,
    ) {
        let file = OpenOptions::new()
            .append(true)
            .create(true)
            .open("debug.log".to_string())
            .unwrap();
        let _ = write!(
            &file,
            "{:?}, {}, {}, {}, {}, {}\n",
            &operator_id,
            &w.to_string(),
            &ts.to_string(),
            &operator_type,
            &input1.clone().into_record(),
            &out.clone().into_record()
        );
        ()
    }
    
    pub fn debug_debug_event_join<
        T1: ToString,
        A1: Clone + IntoRecord,
        A2: Clone + IntoRecord,
        A3: Clone + IntoRecord,
    >(
        operator_id: &(u32, u32, u32),
        w: &std_DDWeight,
        ts: &T1,
        input1: &A1,
        input2: &A2,
        out: &A3,
    ) {
        let file = OpenOptions::new()
            .append(true)
            .create(true)
            .open("debug.log".to_string())
            .unwrap();
        let _ = write!(
            &file,
            "{:?}, {}, {}, Join, {}, {}, {}\n",
            &operator_id,
            &w.to_string(),
            &ts.to_string(),
            &input1.clone().into_record(),
            &input2.clone().into_record(),
            &out.clone().into_record()
        );
        ()
    }
    
    pub fn debug_debug_split_group<'a, K, I: 'static + Clone, V: 'static>(
        g: &'a std_Group<'a, K, (I, V)>,
    ) -> (std_Vec<I>, std_Group<'a, K, V>) {
        let mut inputs = std_Vec::with_capacity(std_group_count(g) as usize);
        for (i, _) in g.iter() {
            inputs.push(i.clone())
        }
        let orig_project = g.project.clone();
        (
            inputs,
            std_Group::new(
                g.key,
                g.group,
                std::rc::Rc::new(move |v| (orig_project)(v).1),
            ),
        )
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default, Serialize, Deserialize)]
pub struct ClampUnknownInt {
    pub id: ExprId,
    pub kind: internment_Intern<ExprKind>,
    pub ty: internment_Intern<TypeKind>
}
impl abomonation::Abomonation for ClampUnknownInt{}
impl <> record::FromRecord for ClampUnknownInt<> {
    fn from_record(val: &record::Record) -> result::Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "ClampUnknownInt" if _args.len() == 3 => {
                        Ok(ClampUnknownInt{id: <ExprId>::from_record(&_args[0])?, kind: <internment_Intern<ExprKind>>::from_record(&_args[1])?, ty: <internment_Intern<TypeKind>>::from_record(&_args[2])?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type ClampUnknownInt in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "ClampUnknownInt" => {
                        Ok(ClampUnknownInt{id: record::arg_extract::<ExprId>(_args, "id")?, kind: record::arg_extract::<internment_Intern<ExprKind>>(_args, "kind")?, ty: record::arg_extract::<internment_Intern<TypeKind>>(_args, "ty")?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type ClampUnknownInt in {:?}", c, *val))
                }
            },
            record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e|format!("{}", e))
                } else {
                    result::Result::Err(format!("unsupported serialization format '{}'", format))
                }
            },
            v => {
                result::Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(ClampUnknownInt["ClampUnknownInt"]<>, id, kind, ty);
decl_record_mutator_struct!(ClampUnknownInt, <>, id: ExprId, kind: internment_Intern<ExprKind>, ty: internment_Intern<TypeKind>);
impl fmt::Display for ClampUnknownInt {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ClampUnknownInt{id,kind,ty} => {
                __formatter.write_str("ClampUnknownInt{")?;
                fmt::Debug::fmt(id, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(kind, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(ty, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for ClampUnknownInt {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default, Serialize, Deserialize)]
pub struct Errors {
    pub message: String
}
impl abomonation::Abomonation for Errors{}
impl <> record::FromRecord for Errors<> {
    fn from_record(val: &record::Record) -> result::Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Errors" if _args.len() == 1 => {
                        Ok(Errors{message: <String>::from_record(&_args[0])?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type Errors in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Errors" => {
                        Ok(Errors{message: record::arg_extract::<String>(_args, "message")?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type Errors in {:?}", c, *val))
                }
            },
            record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e|format!("{}", e))
                } else {
                    result::Result::Err(format!("unsupported serialization format '{}'", format))
                }
            },
            v => {
                result::Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(Errors["Errors"]<>, message);
decl_record_mutator_struct!(Errors, <>, message: String);
impl fmt::Display for Errors {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Errors{message} => {
                __formatter.write_str("Errors{")?;
                record::format_ddlog_str(message, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for Errors {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default, Serialize, Deserialize)]
pub struct Expr {
    pub id: ExprId,
    pub kind: internment_Intern<ExprKind>,
    pub ty: internment_Intern<TypeKind>
}
impl abomonation::Abomonation for Expr{}
impl <> record::FromRecord for Expr<> {
    fn from_record(val: &record::Record) -> result::Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Expr" if _args.len() == 3 => {
                        Ok(Expr{id: <ExprId>::from_record(&_args[0])?, kind: <internment_Intern<ExprKind>>::from_record(&_args[1])?, ty: <internment_Intern<TypeKind>>::from_record(&_args[2])?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type Expr in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Expr" => {
                        Ok(Expr{id: record::arg_extract::<ExprId>(_args, "id")?, kind: record::arg_extract::<internment_Intern<ExprKind>>(_args, "kind")?, ty: record::arg_extract::<internment_Intern<TypeKind>>(_args, "ty")?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type Expr in {:?}", c, *val))
                }
            },
            record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e|format!("{}", e))
                } else {
                    result::Result::Err(format!("unsupported serialization format '{}'", format))
                }
            },
            v => {
                result::Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(Expr["Expr"]<>, id, kind, ty);
decl_record_mutator_struct!(Expr, <>, id: ExprId, kind: internment_Intern<ExprKind>, ty: internment_Intern<TypeKind>);
impl fmt::Display for Expr {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Expr{id,kind,ty} => {
                __formatter.write_str("Expr{")?;
                fmt::Debug::fmt(id, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(kind, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(ty, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for Expr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
pub type ExprId = std_u64;
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize)]
pub enum ExprKind {
    Lit {
        lit: internment_Intern<LiteralVal>
    },
    Variable {
        variable: Var
    },
    Assign {
        variable: Var,
        expr_id: ExprId
    }
}
impl abomonation::Abomonation for ExprKind{}
impl <> record::FromRecord for ExprKind<> {
    fn from_record(val: &record::Record) -> result::Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Lit" if _args.len() == 1 => {
                        Ok(ExprKind::Lit{lit: <internment_Intern<LiteralVal>>::from_record(&_args[0])?})
                    },
                    "Variable" if _args.len() == 1 => {
                        Ok(ExprKind::Variable{variable: <Var>::from_record(&_args[0])?})
                    },
                    "Assign" if _args.len() == 2 => {
                        Ok(ExprKind::Assign{variable: <Var>::from_record(&_args[0])?, expr_id: <ExprId>::from_record(&_args[1])?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type ExprKind in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Lit" => {
                        Ok(ExprKind::Lit{lit: record::arg_extract::<internment_Intern<LiteralVal>>(_args, "lit")?})
                    },
                    "Variable" => {
                        Ok(ExprKind::Variable{variable: record::arg_extract::<Var>(_args, "variable")?})
                    },
                    "Assign" => {
                        Ok(ExprKind::Assign{variable: record::arg_extract::<Var>(_args, "variable")?, expr_id: record::arg_extract::<ExprId>(_args, "expr_id")?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type ExprKind in {:?}", c, *val))
                }
            },
            record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e|format!("{}", e))
                } else {
                    result::Result::Err(format!("unsupported serialization format '{}'", format))
                }
            },
            v => {
                result::Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_enum_into_record!(ExprKind, <>, Lit["Lit"]{lit}, Variable["Variable"]{variable}, Assign["Assign"]{variable, expr_id});
decl_record_mutator_enum!(ExprKind, <>, Lit{lit: internment_Intern<LiteralVal>}, Variable{variable: Var}, Assign{variable: Var, expr_id: ExprId});
impl fmt::Display for ExprKind {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ExprKind::Lit{lit} => {
                __formatter.write_str("Lit{")?;
                fmt::Debug::fmt(lit, __formatter)?;
                __formatter.write_str("}")
            },
            ExprKind::Variable{variable} => {
                __formatter.write_str("Variable{")?;
                fmt::Debug::fmt(variable, __formatter)?;
                __formatter.write_str("}")
            },
            ExprKind::Assign{variable,expr_id} => {
                __formatter.write_str("Assign{")?;
                fmt::Debug::fmt(variable, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(expr_id, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for ExprKind {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
impl  Default for ExprKind {
    fn default() -> Self {
        ExprKind::Lit{lit : Default::default()}
    }
}
pub type FileId = std_u32;
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default, Serialize, Deserialize)]
pub struct FuncArg {
    pub name: Var,
    pub kind: internment_Intern<TypeKind>
}
impl abomonation::Abomonation for FuncArg{}
impl <> record::FromRecord for FuncArg<> {
    fn from_record(val: &record::Record) -> result::Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "FuncArg" if _args.len() == 2 => {
                        Ok(FuncArg{name: <Var>::from_record(&_args[0])?, kind: <internment_Intern<TypeKind>>::from_record(&_args[1])?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type FuncArg in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "FuncArg" => {
                        Ok(FuncArg{name: record::arg_extract::<Var>(_args, "name")?, kind: record::arg_extract::<internment_Intern<TypeKind>>(_args, "kind")?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type FuncArg in {:?}", c, *val))
                }
            },
            record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e|format!("{}", e))
                } else {
                    result::Result::Err(format!("unsupported serialization format '{}'", format))
                }
            },
            v => {
                result::Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(FuncArg["FuncArg"]<>, name, kind);
decl_record_mutator_struct!(FuncArg, <>, name: Var, kind: internment_Intern<TypeKind>);
impl fmt::Display for FuncArg {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            FuncArg{name,kind} => {
                __formatter.write_str("FuncArg{")?;
                fmt::Debug::fmt(name, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(kind, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for FuncArg {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default, Serialize, Deserialize)]
pub struct Function {
    pub name: ItemPath,
    pub vis: Vis,
    pub args: std_Vec<FuncArg>,
    pub body: internment_Intern<Stmt>,
    pub ret: internment_Intern<TypeKind>
}
impl abomonation::Abomonation for Function{}
impl <> record::FromRecord for Function<> {
    fn from_record(val: &record::Record) -> result::Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Function" if _args.len() == 5 => {
                        Ok(Function{name: <ItemPath>::from_record(&_args[0])?, vis: <Vis>::from_record(&_args[1])?, args: <std_Vec<FuncArg>>::from_record(&_args[2])?, body: <internment_Intern<Stmt>>::from_record(&_args[3])?, ret: <internment_Intern<TypeKind>>::from_record(&_args[4])?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type Function in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Function" => {
                        Ok(Function{name: record::arg_extract::<ItemPath>(_args, "name")?, vis: record::arg_extract::<Vis>(_args, "vis")?, args: record::arg_extract::<std_Vec<FuncArg>>(_args, "args")?, body: record::arg_extract::<internment_Intern<Stmt>>(_args, "body")?, ret: record::arg_extract::<internment_Intern<TypeKind>>(_args, "ret")?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type Function in {:?}", c, *val))
                }
            },
            record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e|format!("{}", e))
                } else {
                    result::Result::Err(format!("unsupported serialization format '{}'", format))
                }
            },
            v => {
                result::Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(Function["Function"]<>, name, vis, args, body, ret);
decl_record_mutator_struct!(Function, <>, name: ItemPath, vis: Vis, args: std_Vec<FuncArg>, body: internment_Intern<Stmt>, ret: internment_Intern<TypeKind>);
impl fmt::Display for Function {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Function{name,vis,args,body,ret} => {
                __formatter.write_str("Function{")?;
                fmt::Debug::fmt(name, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(vis, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(args, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(body, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(ret, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for Function {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default, Serialize, Deserialize)]
pub struct Functions {
    pub func: internment_Intern<Function>
}
impl abomonation::Abomonation for Functions{}
impl <> record::FromRecord for Functions<> {
    fn from_record(val: &record::Record) -> result::Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Functions" if _args.len() == 1 => {
                        Ok(Functions{func: <internment_Intern<Function>>::from_record(&_args[0])?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type Functions in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Functions" => {
                        Ok(Functions{func: record::arg_extract::<internment_Intern<Function>>(_args, "func")?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type Functions in {:?}", c, *val))
                }
            },
            record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e|format!("{}", e))
                } else {
                    result::Result::Err(format!("unsupported serialization format '{}'", format))
                }
            },
            v => {
                result::Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(Functions["Functions"]<>, func);
decl_record_mutator_struct!(Functions, <>, func: internment_Intern<Function>);
impl fmt::Display for Functions {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Functions{func} => {
                __formatter.write_str("Functions{")?;
                fmt::Debug::fmt(func, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for Functions {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default, Serialize, Deserialize)]
pub struct InputItems {
    pub item: Item
}
impl abomonation::Abomonation for InputItems{}
impl <> record::FromRecord for InputItems<> {
    fn from_record(val: &record::Record) -> result::Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "InputItems" if _args.len() == 1 => {
                        Ok(InputItems{item: <Item>::from_record(&_args[0])?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type InputItems in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "InputItems" => {
                        Ok(InputItems{item: record::arg_extract::<Item>(_args, "item")?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type InputItems in {:?}", c, *val))
                }
            },
            record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e|format!("{}", e))
                } else {
                    result::Result::Err(format!("unsupported serialization format '{}'", format))
                }
            },
            v => {
                result::Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(InputItems["InputItems"]<>, item);
decl_record_mutator_struct!(InputItems, <>, item: Item);
impl fmt::Display for InputItems {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            InputItems{item} => {
                __formatter.write_str("InputItems{")?;
                fmt::Debug::fmt(item, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for InputItems {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize)]
pub enum Item {
    ItemFunc {
        func: Function
    },
    ItemStruct
}
impl abomonation::Abomonation for Item{}
impl <> record::FromRecord for Item<> {
    fn from_record(val: &record::Record) -> result::Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "ItemFunc" if _args.len() == 1 => {
                        Ok(Item::ItemFunc{func: <Function>::from_record(&_args[0])?})
                    },
                    "ItemStruct" if _args.len() == 0 => {
                        Ok(Item::ItemStruct{})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type Item in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "ItemFunc" => {
                        Ok(Item::ItemFunc{func: record::arg_extract::<Function>(_args, "func")?})
                    },
                    "ItemStruct" => {
                        Ok(Item::ItemStruct{})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type Item in {:?}", c, *val))
                }
            },
            record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e|format!("{}", e))
                } else {
                    result::Result::Err(format!("unsupported serialization format '{}'", format))
                }
            },
            v => {
                result::Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_enum_into_record!(Item, <>, ItemFunc["ItemFunc"]{func}, ItemStruct["ItemStruct"]{});
decl_record_mutator_enum!(Item, <>, ItemFunc{func: Function}, ItemStruct{});
impl fmt::Display for Item {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Item::ItemFunc{func} => {
                __formatter.write_str("ItemFunc{")?;
                fmt::Debug::fmt(func, __formatter)?;
                __formatter.write_str("}")
            },
            Item::ItemStruct{} => {
                __formatter.write_str("ItemStruct{")?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for Item {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
impl  Default for Item {
    fn default() -> Self {
        Item::ItemFunc{func : Default::default()}
    }
}
pub type ItemPath = internment_Intern<std_Vec<StrT>>;
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize)]
pub enum LiteralVal {
    String {
        str: String
    },
    Boolean {
        boolean: bool
    },
    Integer {
        int: std_u64
    }
}
impl abomonation::Abomonation for LiteralVal{}
impl <> record::FromRecord for LiteralVal<> {
    fn from_record(val: &record::Record) -> result::Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "String" if _args.len() == 1 => {
                        Ok(LiteralVal::String{str: <String>::from_record(&_args[0])?})
                    },
                    "Boolean" if _args.len() == 1 => {
                        Ok(LiteralVal::Boolean{boolean: <bool>::from_record(&_args[0])?})
                    },
                    "Integer" if _args.len() == 1 => {
                        Ok(LiteralVal::Integer{int: <std_u64>::from_record(&_args[0])?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type LiteralVal in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "String" => {
                        Ok(LiteralVal::String{str: record::arg_extract::<String>(_args, "str")?})
                    },
                    "Boolean" => {
                        Ok(LiteralVal::Boolean{boolean: record::arg_extract::<bool>(_args, "boolean")?})
                    },
                    "Integer" => {
                        Ok(LiteralVal::Integer{int: record::arg_extract::<std_u64>(_args, "int")?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type LiteralVal in {:?}", c, *val))
                }
            },
            record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e|format!("{}", e))
                } else {
                    result::Result::Err(format!("unsupported serialization format '{}'", format))
                }
            },
            v => {
                result::Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_enum_into_record!(LiteralVal, <>, String["String"]{str}, Boolean["Boolean"]{boolean}, Integer["Integer"]{int});
decl_record_mutator_enum!(LiteralVal, <>, String{str: String}, Boolean{boolean: bool}, Integer{int: std_u64});
impl fmt::Display for LiteralVal {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            LiteralVal::String{str} => {
                __formatter.write_str("String{")?;
                record::format_ddlog_str(str, __formatter)?;
                __formatter.write_str("}")
            },
            LiteralVal::Boolean{boolean} => {
                __formatter.write_str("Boolean{")?;
                fmt::Debug::fmt(boolean, __formatter)?;
                __formatter.write_str("}")
            },
            LiteralVal::Integer{int} => {
                __formatter.write_str("Integer{")?;
                fmt::Debug::fmt(int, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for LiteralVal {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
impl  Default for LiteralVal {
    fn default() -> Self {
        LiteralVal::String{str : Default::default()}
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default, Serialize, Deserialize)]
pub struct Location {
    pub span: Span,
    pub file: FileId
}
impl abomonation::Abomonation for Location{}
impl <> record::FromRecord for Location<> {
    fn from_record(val: &record::Record) -> result::Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Location" if _args.len() == 2 => {
                        Ok(Location{span: <Span>::from_record(&_args[0])?, file: <FileId>::from_record(&_args[1])?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type Location in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Location" => {
                        Ok(Location{span: record::arg_extract::<Span>(_args, "span")?, file: record::arg_extract::<FileId>(_args, "file")?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type Location in {:?}", c, *val))
                }
            },
            record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e|format!("{}", e))
                } else {
                    result::Result::Err(format!("unsupported serialization format '{}'", format))
                }
            },
            v => {
                result::Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(Location["Location"]<>, span, file);
decl_record_mutator_struct!(Location, <>, span: Span, file: FileId);
impl fmt::Display for Location {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Location{span,file} => {
                __formatter.write_str("Location{")?;
                fmt::Debug::fmt(span, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(file, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for Location {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default, Serialize, Deserialize)]
pub struct PropagateExprType {
    pub id: ExprId,
    pub kind: internment_Intern<ExprKind>,
    pub ty: internment_Intern<TypeKind>
}
impl abomonation::Abomonation for PropagateExprType{}
impl <> record::FromRecord for PropagateExprType<> {
    fn from_record(val: &record::Record) -> result::Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "PropagateExprType" if _args.len() == 3 => {
                        Ok(PropagateExprType{id: <ExprId>::from_record(&_args[0])?, kind: <internment_Intern<ExprKind>>::from_record(&_args[1])?, ty: <internment_Intern<TypeKind>>::from_record(&_args[2])?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type PropagateExprType in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "PropagateExprType" => {
                        Ok(PropagateExprType{id: record::arg_extract::<ExprId>(_args, "id")?, kind: record::arg_extract::<internment_Intern<ExprKind>>(_args, "kind")?, ty: record::arg_extract::<internment_Intern<TypeKind>>(_args, "ty")?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type PropagateExprType in {:?}", c, *val))
                }
            },
            record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e|format!("{}", e))
                } else {
                    result::Result::Err(format!("unsupported serialization format '{}'", format))
                }
            },
            v => {
                result::Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(PropagateExprType["PropagateExprType"]<>, id, kind, ty);
decl_record_mutator_struct!(PropagateExprType, <>, id: ExprId, kind: internment_Intern<ExprKind>, ty: internment_Intern<TypeKind>);
impl fmt::Display for PropagateExprType {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            PropagateExprType{id,kind,ty} => {
                __formatter.write_str("PropagateExprType{")?;
                fmt::Debug::fmt(id, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(kind, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(ty, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for PropagateExprType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize)]
pub enum Scope {
    ScopeFunction {
        func: internment_Intern<Function>
    },
    ScopeSeq1 {
        parent: internment_Intern<Scope>
    },
    ScopeSeq2 {
        parent: internment_Intern<Scope>
    }
}
impl abomonation::Abomonation for Scope{}
impl <> record::FromRecord for Scope<> {
    fn from_record(val: &record::Record) -> result::Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "ScopeFunction" if _args.len() == 1 => {
                        Ok(Scope::ScopeFunction{func: <internment_Intern<Function>>::from_record(&_args[0])?})
                    },
                    "ScopeSeq1" if _args.len() == 1 => {
                        Ok(Scope::ScopeSeq1{parent: <internment_Intern<Scope>>::from_record(&_args[0])?})
                    },
                    "ScopeSeq2" if _args.len() == 1 => {
                        Ok(Scope::ScopeSeq2{parent: <internment_Intern<Scope>>::from_record(&_args[0])?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type Scope in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "ScopeFunction" => {
                        Ok(Scope::ScopeFunction{func: record::arg_extract::<internment_Intern<Function>>(_args, "func")?})
                    },
                    "ScopeSeq1" => {
                        Ok(Scope::ScopeSeq1{parent: record::arg_extract::<internment_Intern<Scope>>(_args, "parent")?})
                    },
                    "ScopeSeq2" => {
                        Ok(Scope::ScopeSeq2{parent: record::arg_extract::<internment_Intern<Scope>>(_args, "parent")?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type Scope in {:?}", c, *val))
                }
            },
            record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e|format!("{}", e))
                } else {
                    result::Result::Err(format!("unsupported serialization format '{}'", format))
                }
            },
            v => {
                result::Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_enum_into_record!(Scope, <>, ScopeFunction["ScopeFunction"]{func}, ScopeSeq1["ScopeSeq1"]{parent}, ScopeSeq2["ScopeSeq2"]{parent});
decl_record_mutator_enum!(Scope, <>, ScopeFunction{func: internment_Intern<Function>}, ScopeSeq1{parent: internment_Intern<Scope>}, ScopeSeq2{parent: internment_Intern<Scope>});
impl fmt::Display for Scope {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Scope::ScopeFunction{func} => {
                __formatter.write_str("ScopeFunction{")?;
                fmt::Debug::fmt(func, __formatter)?;
                __formatter.write_str("}")
            },
            Scope::ScopeSeq1{parent} => {
                __formatter.write_str("ScopeSeq1{")?;
                fmt::Debug::fmt(parent, __formatter)?;
                __formatter.write_str("}")
            },
            Scope::ScopeSeq2{parent} => {
                __formatter.write_str("ScopeSeq2{")?;
                fmt::Debug::fmt(parent, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for Scope {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
impl  Default for Scope {
    fn default() -> Self {
        Scope::ScopeFunction{func : Default::default()}
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default, Serialize, Deserialize)]
pub struct Signature {
    pub args: std_Vec<FuncArg>,
    pub ret: internment_Intern<TypeKind>
}
impl abomonation::Abomonation for Signature{}
impl <> record::FromRecord for Signature<> {
    fn from_record(val: &record::Record) -> result::Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "FuncSig" if _args.len() == 2 => {
                        Ok(Signature{args: <std_Vec<FuncArg>>::from_record(&_args[0])?, ret: <internment_Intern<TypeKind>>::from_record(&_args[1])?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type Signature in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "FuncSig" => {
                        Ok(Signature{args: record::arg_extract::<std_Vec<FuncArg>>(_args, "args")?, ret: record::arg_extract::<internment_Intern<TypeKind>>(_args, "ret")?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type Signature in {:?}", c, *val))
                }
            },
            record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e|format!("{}", e))
                } else {
                    result::Result::Err(format!("unsupported serialization format '{}'", format))
                }
            },
            v => {
                result::Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(Signature["Signature"]<>, args, ret);
decl_record_mutator_struct!(Signature, <>, args: std_Vec<FuncArg>, ret: internment_Intern<TypeKind>);
impl fmt::Display for Signature {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Signature{args,ret} => {
                __formatter.write_str("FuncSig{")?;
                fmt::Debug::fmt(args, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(ret, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for Signature {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default, Serialize, Deserialize)]
pub struct Span {
    pub start: std_u32,
    pub end: std_u32
}
impl abomonation::Abomonation for Span{}
impl <> record::FromRecord for Span<> {
    fn from_record(val: &record::Record) -> result::Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Span" if _args.len() == 2 => {
                        Ok(Span{start: <std_u32>::from_record(&_args[0])?, end: <std_u32>::from_record(&_args[1])?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type Span in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Span" => {
                        Ok(Span{start: record::arg_extract::<std_u32>(_args, "start")?, end: record::arg_extract::<std_u32>(_args, "end")?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type Span in {:?}", c, *val))
                }
            },
            record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e|format!("{}", e))
                } else {
                    result::Result::Err(format!("unsupported serialization format '{}'", format))
                }
            },
            v => {
                result::Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(Span["Span"]<>, start, end);
decl_record_mutator_struct!(Span, <>, start: std_u32, end: std_u32);
impl fmt::Display for Span {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Span{start,end} => {
                __formatter.write_str("Span{")?;
                fmt::Debug::fmt(start, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(end, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for Span {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default, Serialize, Deserialize)]
pub struct Statements {
    pub stmt: internment_Intern<Stmt>,
    pub scope: internment_Intern<Scope>
}
impl abomonation::Abomonation for Statements{}
impl <> record::FromRecord for Statements<> {
    fn from_record(val: &record::Record) -> result::Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Statements" if _args.len() == 2 => {
                        Ok(Statements{stmt: <internment_Intern<Stmt>>::from_record(&_args[0])?, scope: <internment_Intern<Scope>>::from_record(&_args[1])?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type Statements in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Statements" => {
                        Ok(Statements{stmt: record::arg_extract::<internment_Intern<Stmt>>(_args, "stmt")?, scope: record::arg_extract::<internment_Intern<Scope>>(_args, "scope")?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type Statements in {:?}", c, *val))
                }
            },
            record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e|format!("{}", e))
                } else {
                    result::Result::Err(format!("unsupported serialization format '{}'", format))
                }
            },
            v => {
                result::Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(Statements["Statements"]<>, stmt, scope);
decl_record_mutator_struct!(Statements, <>, stmt: internment_Intern<Stmt>, scope: internment_Intern<Scope>);
impl fmt::Display for Statements {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Statements{stmt,scope} => {
                __formatter.write_str("Statements{")?;
                fmt::Debug::fmt(stmt, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(scope, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for Statements {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize)]
pub enum Stmt {
    StmtExpr {
        expr: ExprId
    },
    StmtItem {
        item: Item
    },
    StmtSeq {
        first: internment_Intern<Stmt>,
        second: internment_Intern<Stmt>
    }
}
impl abomonation::Abomonation for Stmt{}
impl <> record::FromRecord for Stmt<> {
    fn from_record(val: &record::Record) -> result::Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "StmtExpr" if _args.len() == 1 => {
                        Ok(Stmt::StmtExpr{expr: <ExprId>::from_record(&_args[0])?})
                    },
                    "StmtItem" if _args.len() == 1 => {
                        Ok(Stmt::StmtItem{item: <Item>::from_record(&_args[0])?})
                    },
                    "StmtSeq" if _args.len() == 2 => {
                        Ok(Stmt::StmtSeq{first: <internment_Intern<Stmt>>::from_record(&_args[0])?, second: <internment_Intern<Stmt>>::from_record(&_args[1])?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type Stmt in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "StmtExpr" => {
                        Ok(Stmt::StmtExpr{expr: record::arg_extract::<ExprId>(_args, "expr")?})
                    },
                    "StmtItem" => {
                        Ok(Stmt::StmtItem{item: record::arg_extract::<Item>(_args, "item")?})
                    },
                    "StmtSeq" => {
                        Ok(Stmt::StmtSeq{first: record::arg_extract::<internment_Intern<Stmt>>(_args, "first")?, second: record::arg_extract::<internment_Intern<Stmt>>(_args, "second")?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type Stmt in {:?}", c, *val))
                }
            },
            record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e|format!("{}", e))
                } else {
                    result::Result::Err(format!("unsupported serialization format '{}'", format))
                }
            },
            v => {
                result::Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_enum_into_record!(Stmt, <>, StmtExpr["StmtExpr"]{expr}, StmtItem["StmtItem"]{item}, StmtSeq["StmtSeq"]{first, second});
decl_record_mutator_enum!(Stmt, <>, StmtExpr{expr: ExprId}, StmtItem{item: Item}, StmtSeq{first: internment_Intern<Stmt>, second: internment_Intern<Stmt>});
impl fmt::Display for Stmt {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Stmt::StmtExpr{expr} => {
                __formatter.write_str("StmtExpr{")?;
                fmt::Debug::fmt(expr, __formatter)?;
                __formatter.write_str("}")
            },
            Stmt::StmtItem{item} => {
                __formatter.write_str("StmtItem{")?;
                fmt::Debug::fmt(item, __formatter)?;
                __formatter.write_str("}")
            },
            Stmt::StmtSeq{first,second} => {
                __formatter.write_str("StmtSeq{")?;
                fmt::Debug::fmt(first, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(second, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for Stmt {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
impl  Default for Stmt {
    fn default() -> Self {
        Stmt::StmtExpr{expr : Default::default()}
    }
}
pub type StrT = std_u32;
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default, Serialize, Deserialize)]
pub struct SymbolTable {
    pub path: ItemPath,
    pub signature: Signature
}
impl abomonation::Abomonation for SymbolTable{}
impl <> record::FromRecord for SymbolTable<> {
    fn from_record(val: &record::Record) -> result::Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "SymbolTable" if _args.len() == 2 => {
                        Ok(SymbolTable{path: <ItemPath>::from_record(&_args[0])?, signature: <Signature>::from_record(&_args[1])?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type SymbolTable in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "SymbolTable" => {
                        Ok(SymbolTable{path: record::arg_extract::<ItemPath>(_args, "path")?, signature: record::arg_extract::<Signature>(_args, "signature")?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type SymbolTable in {:?}", c, *val))
                }
            },
            record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e|format!("{}", e))
                } else {
                    result::Result::Err(format!("unsupported serialization format '{}'", format))
                }
            },
            v => {
                result::Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(SymbolTable["SymbolTable"]<>, path, signature);
decl_record_mutator_struct!(SymbolTable, <>, path: ItemPath, signature: Signature);
impl fmt::Display for SymbolTable {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            SymbolTable{path,signature} => {
                __formatter.write_str("SymbolTable{")?;
                fmt::Debug::fmt(path, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(signature, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for SymbolTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize)]
pub enum TypeKind {
    Unknown,
    Str,
    Bool,
    Unit,
    Absurd,
    Error,
    Int {
        is_signed: std_Option<bool>,
        width: std_Option<std_u16>
    }
}
impl abomonation::Abomonation for TypeKind{}
impl <> record::FromRecord for TypeKind<> {
    fn from_record(val: &record::Record) -> result::Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "Unknown" if _args.len() == 0 => {
                        Ok(TypeKind::Unknown{})
                    },
                    "Str" if _args.len() == 0 => {
                        Ok(TypeKind::Str{})
                    },
                    "Bool" if _args.len() == 0 => {
                        Ok(TypeKind::Bool{})
                    },
                    "Unit" if _args.len() == 0 => {
                        Ok(TypeKind::Unit{})
                    },
                    "Absurd" if _args.len() == 0 => {
                        Ok(TypeKind::Absurd{})
                    },
                    "Error" if _args.len() == 0 => {
                        Ok(TypeKind::Error{})
                    },
                    "Int" if _args.len() == 2 => {
                        Ok(TypeKind::Int{is_signed: <std_Option<bool>>::from_record(&_args[0])?, width: <std_Option<std_u16>>::from_record(&_args[1])?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type TypeKind in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "Unknown" => {
                        Ok(TypeKind::Unknown{})
                    },
                    "Str" => {
                        Ok(TypeKind::Str{})
                    },
                    "Bool" => {
                        Ok(TypeKind::Bool{})
                    },
                    "Unit" => {
                        Ok(TypeKind::Unit{})
                    },
                    "Absurd" => {
                        Ok(TypeKind::Absurd{})
                    },
                    "Error" => {
                        Ok(TypeKind::Error{})
                    },
                    "Int" => {
                        Ok(TypeKind::Int{is_signed: record::arg_extract::<std_Option<bool>>(_args, "is_signed")?, width: record::arg_extract::<std_Option<std_u16>>(_args, "width")?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type TypeKind in {:?}", c, *val))
                }
            },
            record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e|format!("{}", e))
                } else {
                    result::Result::Err(format!("unsupported serialization format '{}'", format))
                }
            },
            v => {
                result::Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_enum_into_record!(TypeKind, <>, Unknown["Unknown"]{}, Str["Str"]{}, Bool["Bool"]{}, Unit["Unit"]{}, Absurd["Absurd"]{}, Error["Error"]{}, Int["Int"]{is_signed, width});
decl_record_mutator_enum!(TypeKind, <>, Unknown{}, Str{}, Bool{}, Unit{}, Absurd{}, Error{}, Int{is_signed: std_Option<bool>, width: std_Option<std_u16>});
impl fmt::Display for TypeKind {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            TypeKind::Unknown{} => {
                __formatter.write_str("Unknown{")?;
                __formatter.write_str("}")
            },
            TypeKind::Str{} => {
                __formatter.write_str("Str{")?;
                __formatter.write_str("}")
            },
            TypeKind::Bool{} => {
                __formatter.write_str("Bool{")?;
                __formatter.write_str("}")
            },
            TypeKind::Unit{} => {
                __formatter.write_str("Unit{")?;
                __formatter.write_str("}")
            },
            TypeKind::Absurd{} => {
                __formatter.write_str("Absurd{")?;
                __formatter.write_str("}")
            },
            TypeKind::Error{} => {
                __formatter.write_str("Error{")?;
                __formatter.write_str("}")
            },
            TypeKind::Int{is_signed,width} => {
                __formatter.write_str("Int{")?;
                fmt::Debug::fmt(is_signed, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(width, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for TypeKind {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
impl  Default for TypeKind {
    fn default() -> Self {
        TypeKind::Unknown{}
    }
}
pub type Var = std_u64;
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize)]
pub enum Vis {
    FileLocal,
    Package,
    Exposed
}
impl abomonation::Abomonation for Vis{}
impl <> record::FromRecord for Vis<> {
    fn from_record(val: &record::Record) -> result::Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "FileLocal" if _args.len() == 0 => {
                        Ok(Vis::FileLocal{})
                    },
                    "Package" if _args.len() == 0 => {
                        Ok(Vis::Package{})
                    },
                    "Exposed" if _args.len() == 0 => {
                        Ok(Vis::Exposed{})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type Vis in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "FileLocal" => {
                        Ok(Vis::FileLocal{})
                    },
                    "Package" => {
                        Ok(Vis::Package{})
                    },
                    "Exposed" => {
                        Ok(Vis::Exposed{})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type Vis in {:?}", c, *val))
                }
            },
            record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e|format!("{}", e))
                } else {
                    result::Result::Err(format!("unsupported serialization format '{}'", format))
                }
            },
            v => {
                result::Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_enum_into_record!(Vis, <>, FileLocal["FileLocal"]{}, Package["Package"]{}, Exposed["Exposed"]{});
decl_record_mutator_enum!(Vis, <>, FileLocal{}, Package{}, Exposed{});
impl fmt::Display for Vis {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Vis::FileLocal{} => {
                __formatter.write_str("FileLocal{")?;
                __formatter.write_str("}")
            },
            Vis::Package{} => {
                __formatter.write_str("Package{")?;
                __formatter.write_str("}")
            },
            Vis::Exposed{} => {
                __formatter.write_str("Exposed{")?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for Vis {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
impl  Default for Vis {
    fn default() -> Self {
        Vis::FileLocal{}
    }
}
pub type debug_DDlogOpId = (std_u32, std_u32, std_u32);
pub type internment_istring = internment_Intern<String>;
pub type log_log_level_t = i32;
pub type log_module_t = i32;
pub type std_DDEpoch = std_u64;
pub type std_DDIteration = std_u64;
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Default, Serialize, Deserialize)]
pub struct std_DDNestedTS {
    pub epoch: std_DDEpoch,
    pub iter: std_DDIteration
}
impl abomonation::Abomonation for std_DDNestedTS{}
impl <> record::FromRecord for std_DDNestedTS<> {
    fn from_record(val: &record::Record) -> result::Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "std::DDNestedTS" if _args.len() == 2 => {
                        Ok(std_DDNestedTS{epoch: <std_DDEpoch>::from_record(&_args[0])?, iter: <std_DDIteration>::from_record(&_args[1])?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type std_DDNestedTS in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "std::DDNestedTS" => {
                        Ok(std_DDNestedTS{epoch: record::arg_extract::<std_DDEpoch>(_args, "epoch")?, iter: record::arg_extract::<std_DDIteration>(_args, "iter")?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type std_DDNestedTS in {:?}", c, *val))
                }
            },
            record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e|format!("{}", e))
                } else {
                    result::Result::Err(format!("unsupported serialization format '{}'", format))
                }
            },
            v => {
                result::Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_struct_into_record!(std_DDNestedTS["std::DDNestedTS"]<>, epoch, iter);
decl_record_mutator_struct!(std_DDNestedTS, <>, epoch: std_DDEpoch, iter: std_DDIteration);
impl fmt::Display for std_DDNestedTS {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            std_DDNestedTS{epoch,iter} => {
                __formatter.write_str("std::DDNestedTS{")?;
                fmt::Debug::fmt(epoch, __formatter)?;
                __formatter.write_str(",")?;
                fmt::Debug::fmt(iter, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl fmt::Debug for std_DDNestedTS {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
pub type std_DDWeight = std_s64;
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize)]
pub enum std_Either<A, B> {
    std_Left {
        l: A
    },
    std_Right {
        r: B
    }
}
impl <A: Val, B: Val> abomonation::Abomonation for std_Either<A, B>{}
impl <A: record::FromRecord + serde::de::DeserializeOwned + Default,B: record::FromRecord + serde::de::DeserializeOwned + Default> record::FromRecord for std_Either<A,B> {
    fn from_record(val: &record::Record) -> result::Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "std::Left" if _args.len() == 1 => {
                        Ok(std_Either::std_Left{l: <A>::from_record(&_args[0])?})
                    },
                    "std::Right" if _args.len() == 1 => {
                        Ok(std_Either::std_Right{r: <B>::from_record(&_args[0])?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type std_Either in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "std::Left" => {
                        Ok(std_Either::std_Left{l: record::arg_extract::<A>(_args, "l")?})
                    },
                    "std::Right" => {
                        Ok(std_Either::std_Right{r: record::arg_extract::<B>(_args, "r")?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type std_Either in {:?}", c, *val))
                }
            },
            record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e|format!("{}", e))
                } else {
                    result::Result::Err(format!("unsupported serialization format '{}'", format))
                }
            },
            v => {
                result::Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_enum_into_record!(std_Either, <A,B>, std_Left["std::Left"]{l}, std_Right["std::Right"]{r});
decl_record_mutator_enum!(std_Either, <A,B>, std_Left{l: A}, std_Right{r: B});
impl <A: fmt::Debug, B: fmt::Debug> fmt::Display for std_Either<A, B> {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            std_Either::std_Left{l} => {
                __formatter.write_str("std::Left{")?;
                fmt::Debug::fmt(l, __formatter)?;
                __formatter.write_str("}")
            },
            std_Either::std_Right{r} => {
                __formatter.write_str("std::Right{")?;
                fmt::Debug::fmt(r, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl <A: fmt::Debug, B: fmt::Debug> fmt::Debug for std_Either<A, B> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
impl  <A: Default, B: Default> Default for std_Either<A, B> {
    fn default() -> Self {
        std_Either::std_Left{l : Default::default()}
    }
}
#[serde(from="Option<A>", into="Option<A>", bound(serialize="A: Clone+Serialize"))]
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize)]
pub enum std_Option<A> {
    std_None,
    std_Some {
        x: A
    }
}
impl <A: Val> abomonation::Abomonation for std_Option<A>{}
decl_enum_into_record!(std_Option, <A>, std_None["std::None"]{}, std_Some["std::Some"]{x});
decl_record_mutator_enum!(std_Option, <A>, std_None{}, std_Some{x: A});
impl <A: fmt::Debug> fmt::Display for std_Option<A> {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            std_Option::std_None{} => {
                __formatter.write_str("std::None{")?;
                __formatter.write_str("}")
            },
            std_Option::std_Some{x} => {
                __formatter.write_str("std::Some{")?;
                fmt::Debug::fmt(x, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl <A: fmt::Debug> fmt::Debug for std_Option<A> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
impl  <A: Default> Default for std_Option<A> {
    fn default() -> Self {
        std_Option::std_None{}
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, Serialize, Deserialize)]
pub enum std_Result<V, E> {
    std_Ok {
        res: V
    },
    std_Err {
        err: E
    }
}
impl <V: Val, E: Val> abomonation::Abomonation for std_Result<V, E>{}
impl <V: record::FromRecord + serde::de::DeserializeOwned + Default,E: record::FromRecord + serde::de::DeserializeOwned + Default> record::FromRecord for std_Result<V,E> {
    fn from_record(val: &record::Record) -> result::Result<Self, String> {
        match val {
            record::Record::PosStruct(constr, _args) => {
                match constr.as_ref() {
                    "std::Ok" if _args.len() == 1 => {
                        Ok(std_Result::std_Ok{res: <V>::from_record(&_args[0])?})
                    },
                    "std::Err" if _args.len() == 1 => {
                        Ok(std_Result::std_Err{err: <E>::from_record(&_args[0])?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type std_Result in {:?}", c, *val))
                }
            },
            record::Record::NamedStruct(constr, _args) => {
                match constr.as_ref() {
                    "std::Ok" => {
                        Ok(std_Result::std_Ok{res: record::arg_extract::<V>(_args, "res")?})
                    },
                    "std::Err" => {
                        Ok(std_Result::std_Err{err: record::arg_extract::<E>(_args, "err")?})
                    },
                    c => result::Result::Err(format!("unknown constructor {} of type std_Result in {:?}", c, *val))
                }
            },
            record::Record::Serialized(format, s) => {
                if format == "json" {
                    serde_json::from_str(&*s).map_err(|e|format!("{}", e))
                } else {
                    result::Result::Err(format!("unsupported serialization format '{}'", format))
                }
            },
            v => {
                result::Result::Err(format!("not a struct {:?}", *v))
            }
        }
    }
}
decl_enum_into_record!(std_Result, <V,E>, std_Ok["std::Ok"]{res}, std_Err["std::Err"]{err});
decl_record_mutator_enum!(std_Result, <V,E>, std_Ok{res: V}, std_Err{err: E});
impl <V: fmt::Debug, E: fmt::Debug> fmt::Display for std_Result<V, E> {
    fn fmt(&self, __formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            std_Result::std_Ok{res} => {
                __formatter.write_str("std::Ok{")?;
                fmt::Debug::fmt(res, __formatter)?;
                __formatter.write_str("}")
            },
            std_Result::std_Err{err} => {
                __formatter.write_str("std::Err{")?;
                fmt::Debug::fmt(err, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl <V: fmt::Debug, E: fmt::Debug> fmt::Debug for std_Result<V, E> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(&self, f)
    }
}
impl  <V: Default, E: Default> Default for std_Result<V, E> {
    fn default() -> Self {
        std_Result::std_Ok{res : Default::default()}
    }
}
pub type std_s128 = i128;
pub type std_s16 = i16;
pub type std_s32 = i32;
pub type std_s64 = i64;
pub type std_s8 = i8;
pub type std_u128 = u128;
pub type std_u16 = u16;
pub type std_u32 = u32;
pub type std_u64 = u64;
pub type std_u8 = u8;
pub type std_usize = std_u64;
lazy_static!{ pub static ref __STATIC_4: internment_Intern<std_Vec<u32>> = internment_intern((&*__STATIC_3)) ; }
lazy_static!{ pub static ref __STATIC_0: internment_Intern<TypeKind> = internment_intern((&(TypeKind::Error{}))) ; }
lazy_static!{ pub static ref __STATIC_6: internment_Intern<TypeKind> = internment_intern((&(TypeKind::Int{is_signed: (std_Option::std_Some{x: true}), width: (std_Option::std_Some{x: (32 as u16)})}))) ; }
lazy_static!{ pub static ref __STATIC_2: internment_Intern<TypeKind> = internment_intern((&(TypeKind::Unknown{}))) ; }
lazy_static!{ pub static ref __STATIC_5: std_Vec<String> = std_vec_empty() ; }
lazy_static!{ pub static ref __STATIC_3: std_Vec<u32> = std_vec_empty() ; }
lazy_static!{ pub static ref __STATIC_1: std_Vec<FuncArg> = std_vec_empty() ; }
/* fn debug_debug_event<T1: Val,A1: Val,A2: Val>(operator_id: & debug_DDlogOpId, w: & std_DDWeight, ts: & T1, operator_type: & String, input1: & A1, out: & A2) -> () */
/* fn debug_debug_event_join<T1: Val,A1: Val,A2: Val,A3: Val>(operator_id: & debug_DDlogOpId, w: & std_DDWeight, ts: & T1, input1: & A1, input2: & A2, out: & A3) -> () */
/* fn debug_debug_split_group<K: Val,I: Val,V: Val>(g: & std_Group<K, (I, V)>) -> (std_Vec<I>, std_Group<K, V>) */
/* fn internment_intern<A: Val>(s: & A) -> internment_Intern<A> */
/* fn internment_istring_contains(s1: & internment_istring, s2: & String) -> bool */
/* fn internment_istring_ends_with(s: & internment_istring, suffix: & String) -> bool */
/* fn internment_istring_join(strings: & std_Vec<internment_istring>, sep: & String) -> String */
/* fn internment_istring_len(s: & internment_istring) -> std_usize */
/* fn internment_istring_replace(s: & internment_istring, from: & String, to: & String) -> String */
/* fn internment_istring_reverse(s: & internment_istring) -> String */
/* fn internment_istring_split(s: & internment_istring, sep: & String) -> std_Vec<String> */
/* fn internment_istring_starts_with(s: & internment_istring, prefix: & String) -> bool */
/* fn internment_istring_substr(s: & internment_istring, start: & std_usize, end: & std_usize) -> String */
/* fn internment_istring_to_bytes(s: & internment_istring) -> std_Vec<std_u8> */
/* fn internment_istring_to_lowercase(s: & internment_istring) -> String */
/* fn internment_istring_to_uppercase(s: & internment_istring) -> String */
/* fn internment_istring_trim(s: & internment_istring) -> String */
/* fn internment_ival<A: Val>(s: & internment_Intern<A>) -> A */
/* fn log_log(module: & log_module_t, level: & log_log_level_t, msg: & String) -> () */
/* fn std___builtin_2string<X: Val>(x: & X) -> String */
/* fn std_deref<A: Val>(x: & std_Ref<A>) -> A */
/* fn std_group_count<K: Val,V: Val>(g: & std_Group<K, V>) -> std_usize */
/* fn std_group_first<K: Val,V: Val>(g: & std_Group<K, V>) -> V */
/* fn std_group_key<K: Val,V: Val>(g: & std_Group<K, V>) -> K */
/* fn std_group_max<K: Val,V: Val>(g: & std_Group<K, V>) -> V */
/* fn std_group_min<K: Val,V: Val>(g: & std_Group<K, V>) -> V */
/* fn std_group_nth<K: Val,V: Val>(g: & std_Group<K, V>, n: & std_usize) -> std_Option<V> */
/* fn std_group_set_unions<K: Val,A: Val>(g: & std_Group<K, std_Set<A>>) -> std_Set<A> */
/* fn std_group_setref_unions<K: Val,A: Val>(g: & std_Group<K, std_Ref<std_Set<A>>>) -> std_Ref<std_Set<A>> */
/* fn std_group_sum<K: Val,V: Val>(g: & std_Group<K, V>) -> V */
/* fn std_group_to_map<K1: Val,K2: Val,V: Val>(g: & std_Group<K1, (K2, V)>) -> std_Map<K2, V> */
/* fn std_group_to_set<K: Val,V: Val>(g: & std_Group<K, V>) -> std_Set<V> */
/* fn std_group_to_setmap<K1: Val,K2: Val,V: Val>(g: & std_Group<K1, (K2, V)>) -> std_Map<K2, std_Set<V>> */
/* fn std_group_to_vec<K: Val,V: Val>(g: & std_Group<K, V>) -> std_Vec<V> */
/* fn std_hash128<X: Val>(x: & X) -> u128 */
/* fn std_hash64<X: Val>(x: & X) -> u64 */
/* fn std_hex<X: Val>(x: & X) -> String */
/* fn std_htonl(x: & u32) -> u32 */
/* fn std_htons(x: & u16) -> u16 */
/* fn std_map_contains_key<K: Val,V: Val>(m: & std_Map<K, V>, k: & K) -> bool */
/* fn std_map_empty<K: Val,V: Val>() -> std_Map<K, V> */
/* fn std_map_get<K: Val,V: Val>(m: & std_Map<K, V>, k: & K) -> std_Option<V> */
/* fn std_map_insert<K: Val,V: Val>(m: &mut std_Map<K, V>, k: & K, v: & V) -> () */
/* fn std_map_insert_imm<K: Val,V: Val>(m: & std_Map<K, V>, k: & K, v: & V) -> std_Map<K, V> */
/* fn std_map_is_empty<K: Val,V: Val>(m: & std_Map<K, V>) -> bool */
/* fn std_map_remove<K: Val,V: Val>(m: &mut std_Map<K, V>, k: & K) -> () */
/* fn std_map_singleton<K: Val,V: Val>(k: & K, v: & V) -> std_Map<K, V> */
/* fn std_map_size<K: Val,V: Val>(m: & std_Map<K, V>) -> std_usize */
/* fn std_map_union<K: Val,V: Val>(m1: & std_Map<K, V>, m2: & std_Map<K, V>) -> std_Map<K, V> */
/* fn std_ntohl(x: & u32) -> u32 */
/* fn std_ntohs(x: & u16) -> u16 */
/* fn std_option_unwrap_or_default<A: Val>(opt: & std_Option<A>) -> A */
/* fn std_parse_dec_i64(s: & String) -> std_Option<i64> */
/* fn std_parse_dec_u64(s: & String) -> std_Option<u64> */
/* fn std_pow32<A: Val>(base: & A, exp: & u32) -> A */
/* fn std_range<A: Val>(from: & A, to: & A, step: & A) -> std_Vec<A> */
/* fn std_ref_new<A: Val>(x: & A) -> std_Ref<A> */
/* fn std_result_unwrap_or_default<V: Val,E: Val>(res: & std_Result<V, E>) -> V */
/* fn std_set_contains<X: Val>(s: & std_Set<X>, v: & X) -> bool */
/* fn std_set_difference<X: Val>(s1: & std_Set<X>, s2: & std_Set<X>) -> std_Set<X> */
/* fn std_set_empty<X: Val>() -> std_Set<X> */
/* fn std_set_insert<X: Val>(s: &mut std_Set<X>, v: & X) -> () */
/* fn std_set_insert_imm<X: Val>(s: & std_Set<X>, v: & X) -> std_Set<X> */
/* fn std_set_intersection<X: Val>(s1: & std_Set<X>, s2: & std_Set<X>) -> std_Set<X> */
/* fn std_set_is_empty<X: Val>(s: & std_Set<X>) -> bool */
/* fn std_set_nth<X: Val>(s: & std_Set<X>, n: & std_usize) -> std_Option<X> */
/* fn std_set_singleton<X: Val>(x: & X) -> std_Set<X> */
/* fn std_set_size<X: Val>(s: & std_Set<X>) -> std_usize */
/* fn std_set_to_vec<A: Val>(s: & std_Set<A>) -> std_Vec<A> */
/* fn std_set_union<X: Val>(s1: & std_Set<X>, s2: & std_Set<X>) -> std_Set<X> */
/* fn std_set_unions<X: Val>(sets: & std_Vec<std_Set<X>>) -> std_Set<X> */
/* fn std_str_to_lower(s: & String) -> String */
/* fn std_string_contains(s1: & String, s2: & String) -> bool */
/* fn std_string_ends_with(s: & String, suffix: & String) -> bool */
/* fn std_string_join(strings: & std_Vec<String>, sep: & String) -> String */
/* fn std_string_len(s: & String) -> std_usize */
/* fn std_string_replace(s: & String, from: & String, to: & String) -> String */
/* fn std_string_reverse(s: & String) -> String */
/* fn std_string_split(s: & String, sep: & String) -> std_Vec<String> */
/* fn std_string_starts_with(s: & String, prefix: & String) -> bool */
/* fn std_string_substr(s: & String, start: & std_usize, end: & std_usize) -> String */
/* fn std_string_to_bytes(s: & String) -> std_Vec<std_u8> */
/* fn std_string_to_lowercase(s: & String) -> String */
/* fn std_string_to_uppercase(s: & String) -> String */
/* fn std_string_trim(s: & String) -> String */
/* fn std_vec_append<X: Val>(v: &mut std_Vec<X>, other: & std_Vec<X>) -> () */
/* fn std_vec_contains<X: Val>(v: & std_Vec<X>, x: & X) -> bool */
/* fn std_vec_empty<A: Val>() -> std_Vec<A> */
/* fn std_vec_is_empty<X: Val>(v: & std_Vec<X>) -> bool */
/* fn std_vec_len<X: Val>(v: & std_Vec<X>) -> std_usize */
/* fn std_vec_nth<X: Val>(v: & std_Vec<X>, n: & std_usize) -> std_Option<X> */
/* fn std_vec_push<X: Val>(v: &mut std_Vec<X>, x: & X) -> () */
/* fn std_vec_push_imm<X: Val>(v: & std_Vec<X>, x: & X) -> std_Vec<X> */
/* fn std_vec_singleton<X: Val>(x: & X) -> std_Vec<X> */
/* fn std_vec_sort<X: Val>(v: &mut std_Vec<X>) -> () */
/* fn std_vec_sort_imm<X: Val>(v: & std_Vec<X>) -> std_Vec<X> */
/* fn std_vec_to_set<A: Val>(s: & std_Vec<A>) -> std_Set<A> */
/* fn std_vec_with_capacity<A: Val>(len: & std_usize) -> std_Vec<A> */
/* fn std_vec_with_length<A: Val>(len: & std_usize, x: & A) -> std_Vec<A> */
pub fn corrected_signature(item: & Item) -> Signature
{   match (*item) {
        Item::ItemFunc{func: Function{name: _, vis: _, args: ref old_args, body: _, ret: ref ret}} => {
                                                                                                          let ref mut ret: internment_Intern<TypeKind> = if ((&*internment_ival(ret)) == (&*(&(TypeKind::Unknown{})))) {
                                                                                                                                                             (*(&*__STATIC_0)).clone()
                                                                                                                                                         } else {
                                                                                                                                                             (*ret).clone()
                                                                                                                                                         };
                                                                                                          let ref mut args: std_Vec<FuncArg> = std_vec_with_capacity((&std_len_std_Vec__X_1(old_args)));
                                                                                                          for arg in old_args.iter() {
                                                                                                              {
                                                                                                                  let ref mut arg: FuncArg = if ((&*internment_ival((&arg.kind))) == (&*(&(TypeKind::Unknown{})))) {
                                                                                                                                                 (FuncArg{name: arg.name.clone(), kind: (*(&*__STATIC_0)).clone()})
                                                                                                                                             } else {
                                                                                                                                                 (*arg).clone()
                                                                                                                                             };
                                                                                                                  std_push(args, arg)
                                                                                                              }
                                                                                                          };
                                                                                                          (Signature{args: (*args).clone(), ret: (*ret).clone()})
                                                                                                      },
        Item::ItemStruct{} => (Signature{args: (*(&*__STATIC_1)).clone(), ret: (*(&*__STATIC_2)).clone()})
    }
}
pub fn has_unknown_types(item: & Item) -> bool
{   match (*item) {
        Item::ItemFunc{func: Function{name: _, vis: _, args: ref args, body: _, ret: ref ret}} => (((&*internment_ival(ret)) == (&*(&(TypeKind::Unknown{})))) || {
                                                                                                                                                                     for arg in args.iter() {
                                                                                                                                                                         if ((&*internment_ival((&arg.kind))) == (&*(&(TypeKind::Unknown{})))) {
                                                                                                                                                                             return true
                                                                                                                                                                         } else {
                                                                                                                                                                             ()
                                                                                                                                                                         }
                                                                                                                                                                     };
                                                                                                                                                                     false
                                                                                                                                                                 }),
        Item::ItemStruct{} => false
    }
}
pub fn internment_contains(s1: & internment_istring, s2: & String) -> bool
{   internment_istring_contains(s1, s2)
}
pub fn internment_ends_with(s: & internment_istring, suffix: & String) -> bool
{   internment_istring_ends_with(s, suffix)
}
pub fn internment_join(strings: & std_Vec<internment_istring>, sep: & String) -> String
{   internment_istring_join(strings, sep)
}
pub fn internment_len(s: & internment_istring) -> std_usize
{   internment_istring_len(s)
}
pub fn internment_replace(s: & internment_istring, from: & String, to: & String) -> String
{   internment_istring_replace(s, from, to)
}
pub fn internment_reverse(s: & internment_istring) -> String
{   internment_istring_reverse(s)
}
pub fn internment_split(s: & internment_istring, sep: & String) -> std_Vec<String>
{   internment_istring_split(s, sep)
}
pub fn internment_starts_with(s: & internment_istring, prefix: & String) -> bool
{   internment_istring_starts_with(s, prefix)
}
pub fn internment_substr(s: & internment_istring, start: & std_usize, end: & std_usize) -> String
{   internment_istring_substr(s, start, end)
}
pub fn internment_to_bytes(s: & internment_istring) -> std_Vec<std_u8>
{   internment_istring_to_bytes(s)
}
pub fn internment_to_lowercase(s: & internment_istring) -> String
{   internment_istring_to_lowercase(s)
}
pub fn internment_to_string(s: & internment_istring) -> String
{   (*internment_ival(s)).clone()
}
pub fn internment_to_uppercase(s: & internment_istring) -> String
{   internment_istring_to_uppercase(s)
}
pub fn internment_trim(s: & internment_istring) -> String
{   internment_istring_trim(s)
}
pub fn is_int(ty: & internment_Intern<TypeKind>) -> bool
{   match (*internment_ival(ty)) {
        TypeKind::Int{is_signed: _, width: _} => true,
        _ => false
    }
}
pub fn path(item: & Item) -> ItemPath
{   match (*item) {
        Item::ItemFunc{func: Function{name: ref path, vis: _, args: _, body: _, ret: _}} => (*path).clone(),
        Item::ItemStruct{} => (*(&*__STATIC_4)).clone()
    }
}
pub fn signature(item: & Item) -> Signature
{   match (*item) {
        Item::ItemFunc{func: Function{name: _, vis: _, args: ref args, body: _, ret: ref ret}} => (Signature{args: (*args).clone(), ret: (*ret).clone()}),
        Item::ItemStruct{} => (Signature{args: (*(&*__STATIC_1)).clone(), ret: (*(&*__STATIC_2)).clone()})
    }
}
pub fn std_append<X: Val>(v: &mut std_Vec<X>, other: & std_Vec<X>) -> ()
{   std_vec_append(v, other)
}
pub fn std_contains___Stringval_2(s1: & String, s2: & String) -> bool
{   std_string_contains(s1, s2)
}
pub fn std_contains_std_Vec__X_2<X: Val>(v: & std_Vec<X>, x: & X) -> bool
{   std_vec_contains(v, x)
}
pub fn std_contains_std_Set__X_2<X: Val>(s: & std_Set<X>, v: & X) -> bool
{   std_set_contains(s, v)
}
pub fn std_contains_key<K: Val,V: Val>(m: & std_Map<K, V>, k: & K) -> bool
{   std_map_contains_key(m, k)
}
pub fn std_count<K: Val,V: Val>(g: & std_Group<K, V>) -> std_usize
{   std_group_count(g)
}
pub fn std_difference<X: Val>(s1: & std_Set<X>, s2: & std_Set<X>) -> std_Set<X>
{   std_set_difference(s1, s2)
}
pub fn std_ends_with(s: & String, suffix: & String) -> bool
{   std_string_ends_with(s, suffix)
}
pub fn std_first<K: Val,V: Val>(g: & std_Group<K, V>) -> V
{   std_group_first(g)
}
pub fn std_get<K: Val,V: Val>(m: & std_Map<K, V>, k: & K) -> std_Option<V>
{   std_map_get(m, k)
}
pub fn std_group_unzip<K: Val,X: Val,Y: Val>(g: & std_Group<K, (X, Y)>) -> (std_Vec<X>, std_Vec<Y>)
{   let ref mut xs: std_Vec<X> = std_vec_empty();
    let ref mut ys: std_Vec<Y> = std_vec_empty();
    for ref v in g.iter() {
        {
            let (ref mut x, ref mut y): (X, Y) = (*v).clone();
            std_vec_push(xs, x);
            std_vec_push(ys, y)
        }
    };
    ((*xs).clone(), (*ys).clone())
}
pub fn std_insert_std_Map__K_V_3<K: Val,V: Val>(m: &mut std_Map<K, V>, k: & K, v: & V) -> ()
{   std_map_insert(m, k, v)
}
pub fn std_insert_std_Set__X_2<X: Val>(s: &mut std_Set<X>, v: & X) -> ()
{   std_set_insert(s, v)
}
pub fn std_insert_imm_std_Map__K_V_3<K: Val,V: Val>(m: & std_Map<K, V>, k: & K, v: & V) -> std_Map<K, V>
{   std_map_insert_imm(m, k, v)
}
pub fn std_insert_imm_std_Set__X_2<X: Val>(s: & std_Set<X>, v: & X) -> std_Set<X>
{   std_set_insert_imm(s, v)
}
pub fn std_intersection<X: Val>(s1: & std_Set<X>, s2: & std_Set<X>) -> std_Set<X>
{   std_set_intersection(s1, s2)
}
pub fn std_is_empty_std_Vec__X_1<X: Val>(v: & std_Vec<X>) -> bool
{   std_vec_is_empty(v)
}
pub fn std_is_empty_std_Map__K_V_1<K: Val,V: Val>(m: & std_Map<K, V>) -> bool
{   std_map_is_empty(m)
}
pub fn std_is_empty_std_Set__X_1<X: Val>(s: & std_Set<X>) -> bool
{   std_set_is_empty(s)
}
pub fn std_is_err<V: Val,E: Val>(res: & std_Result<V, E>) -> bool
{   match (*res) {
        std_Result::std_Ok{res: _} => false,
        std_Result::std_Err{err: _} => true
    }
}
pub fn std_is_none<A: Val>(x: & std_Option<A>) -> bool
{   match (*x) {
        std_Option::std_None{} => true,
        _ => false
    }
}
pub fn std_is_ok<V: Val,E: Val>(res: & std_Result<V, E>) -> bool
{   match (*res) {
        std_Result::std_Ok{res: _} => true,
        std_Result::std_Err{err: _} => false
    }
}
pub fn std_is_some<A: Val>(x: & std_Option<A>) -> bool
{   match (*x) {
        std_Option::std_Some{x: _} => true,
        _ => false
    }
}
pub fn std_join(strings: & std_Vec<String>, sep: & String) -> String
{   std_string_join(strings, sep)
}
pub fn std_key<K: Val,V: Val>(g: & std_Group<K, V>) -> K
{   std_group_key(g)
}
pub fn std_len___Stringval_1(s: & String) -> std_usize
{   std_string_len(s)
}
pub fn std_len_std_Vec__X_1<X: Val>(v: & std_Vec<X>) -> std_usize
{   std_vec_len(v)
}
pub fn std_max_A_2<A: Val>(x: & A, y: & A) -> A
{   if ((&*x) > (&*y)) {
        (*x).clone()
    } else {
        (*y).clone()
    }
}
pub fn std_max_std_Group__K_V_1<K: Val,V: Val>(g: & std_Group<K, V>) -> V
{   std_group_max(g)
}
pub fn std_min_A_2<A: Val>(x: & A, y: & A) -> A
{   if ((&*x) < (&*y)) {
        (*x).clone()
    } else {
        (*y).clone()
    }
}
pub fn std_min_std_Group__K_V_1<K: Val,V: Val>(g: & std_Group<K, V>) -> V
{   std_group_min(g)
}
pub fn std_nth_std_Group__K_V_2<K: Val,V: Val>(g: & std_Group<K, V>, n: & std_usize) -> std_Option<V>
{   std_group_nth(g, n)
}
pub fn std_nth_std_Vec__X_2<X: Val>(v: & std_Vec<X>, n: & std_usize) -> std_Option<X>
{   std_vec_nth(v, n)
}
pub fn std_nth_std_Set__X_2<X: Val>(s: & std_Set<X>, n: & std_usize) -> std_Option<X>
{   std_set_nth(s, n)
}
pub fn std_push<X: Val>(v: &mut std_Vec<X>, x: & X) -> ()
{   std_vec_push(v, x)
}
pub fn std_push_imm<X: Val>(v: & std_Vec<X>, x: & X) -> std_Vec<X>
{   std_vec_push_imm(v, x)
}
pub fn std_remove<K: Val,V: Val>(m: &mut std_Map<K, V>, k: & K) -> ()
{   std_map_remove(m, k)
}
pub fn std_replace(s: & String, from: & String, to: & String) -> String
{   std_string_replace(s, from, to)
}
pub fn std_reverse(s: & String) -> String
{   std_string_reverse(s)
}
pub fn std_setref_unions<K: Val,A: Val>(g: & std_Group<K, std_Ref<std_Set<A>>>) -> std_Ref<std_Set<A>>
{   std_group_setref_unions(g)
}
pub fn std_size_std_Map__K_V_1<K: Val,V: Val>(m: & std_Map<K, V>) -> std_usize
{   std_map_size(m)
}
pub fn std_size_std_Set__X_1<X: Val>(s: & std_Set<X>) -> std_usize
{   std_set_size(s)
}
pub fn std_sort<X: Val>(v: &mut std_Vec<X>) -> ()
{   std_vec_sort(v)
}
pub fn std_sort_imm<X: Val>(v: & std_Vec<X>) -> std_Vec<X>
{   std_vec_sort_imm(v)
}
pub fn std_split(s: & String, sep: & String) -> std_Vec<String>
{   std_string_split(s, sep)
}
pub fn std_starts_with(s: & String, prefix: & String) -> bool
{   std_string_starts_with(s, prefix)
}
pub fn std_substr(s: & String, start: & std_usize, end: & std_usize) -> String
{   std_string_substr(s, start, end)
}
pub fn std_to_bytes(s: & String) -> std_Vec<std_u8>
{   std_string_to_bytes(s)
}
pub fn std_to_lowercase(s: & String) -> String
{   std_string_to_lowercase(s)
}
pub fn std_to_map<K1: Val,K2: Val,V: Val>(g: & std_Group<K1, (K2, V)>) -> std_Map<K2, V>
{   std_group_to_map(g)
}
pub fn std_to_set_std_Option__X_1<X: Val>(o: & std_Option<X>) -> std_Set<X>
{   match (*o) {
        std_Option::std_Some{x: ref x} => std_set_singleton(x),
        std_Option::std_None{} => std_set_empty()
    }
}
pub fn std_to_set_std_Group__K_V_1<K: Val,V: Val>(g: & std_Group<K, V>) -> std_Set<V>
{   std_group_to_set(g)
}
pub fn std_to_set_std_Vec__A_1<A: Val>(s: & std_Vec<A>) -> std_Set<A>
{   std_vec_to_set(s)
}
pub fn std_to_setmap<K1: Val,K2: Val,V: Val>(g: & std_Group<K1, (K2, V)>) -> std_Map<K2, std_Set<V>>
{   std_group_to_setmap(g)
}
pub fn std_to_string_std_DDNestedTS_1(ts: & std_DDNestedTS) -> String
{   string_append_str(string_append(string_append_str(string_append(String::from(r###"("###), (&std___builtin_2string((&ts.epoch)))), r###","###), (&std___builtin_2string((&ts.iter)))), r###")"###)
}
pub fn std_to_string___Boolval_1(x: & bool) -> String
{   std___builtin_2string(x)
}
pub fn std_to_string___Intval_1(x: & Int) -> String
{   std___builtin_2string(x)
}
pub fn std_to_string___Floatval_1(x: & OrderedFloat<f32>) -> String
{   std___builtin_2string(x)
}
pub fn std_to_string___Doubleval_1(x: & OrderedFloat<f64>) -> String
{   std___builtin_2string(x)
}
pub fn std_to_string___Signedval8_1(x: & std_s8) -> String
{   std___builtin_2string(x)
}
pub fn std_to_string___Signedval16_1(x: & std_s16) -> String
{   std___builtin_2string(x)
}
pub fn std_to_string___Signedval32_1(x: & std_s32) -> String
{   std___builtin_2string(x)
}
pub fn std_to_string___Signedval64_1(x: & std_s64) -> String
{   std___builtin_2string(x)
}
pub fn std_to_string___Signedval128_1(x: & std_s128) -> String
{   std___builtin_2string(x)
}
pub fn std_to_string___Bitval8_1(x: & std_u8) -> String
{   std___builtin_2string(x)
}
pub fn std_to_string___Bitval16_1(x: & std_u16) -> String
{   std___builtin_2string(x)
}
pub fn std_to_string___Bitval32_1(x: & std_u32) -> String
{   std___builtin_2string(x)
}
pub fn std_to_string___Bitval64_1(x: & std_u64) -> String
{   std___builtin_2string(x)
}
pub fn std_to_string___Bitval128_1(x: & std_u128) -> String
{   std___builtin_2string(x)
}
pub fn std_to_string___Stringval_1(x: & String) -> String
{   std___builtin_2string(x)
}
pub fn std_to_uppercase(s: & String) -> String
{   std_string_to_uppercase(s)
}
pub fn std_to_vec_std_Option__X_1<X: Val>(o: & std_Option<X>) -> std_Vec<X>
{   match (*o) {
        std_Option::std_Some{x: ref x} => std_vec_singleton(x),
        std_Option::std_None{} => std_vec_empty()
    }
}
pub fn std_to_vec_std_Group__K_V_1<K: Val,V: Val>(g: & std_Group<K, V>) -> std_Vec<V>
{   std_group_to_vec(g)
}
pub fn std_to_vec_std_Set__A_1<A: Val>(s: & std_Set<A>) -> std_Vec<A>
{   std_set_to_vec(s)
}
pub fn std_trim(s: & String) -> String
{   std_string_trim(s)
}
pub fn std_union_std_Map__K_V_2<K: Val,V: Val>(m1: & std_Map<K, V>, m2: & std_Map<K, V>) -> std_Map<K, V>
{   std_map_union(m1, m2)
}
pub fn std_union_std_Set__X_2<X: Val>(s1: & std_Set<X>, s2: & std_Set<X>) -> std_Set<X>
{   std_set_union(s1, s2)
}
pub fn std_unions<X: Val>(sets: & std_Vec<std_Set<X>>) -> std_Set<X>
{   std_set_unions(sets)
}
pub fn std_unwrap_or_std_Option__A_2<A: Val>(x: & std_Option<A>, def: & A) -> A
{   match (*x) {
        std_Option::std_Some{x: ref v} => (*v).clone(),
        std_Option::std_None{} => (*def).clone()
    }
}
pub fn std_unwrap_or_std_Result__V_E_2<V: Val,E: Val>(res: & std_Result<V, E>, def: & V) -> V
{   match (*res) {
        std_Result::std_Ok{res: ref v} => (*v).clone(),
        std_Result::std_Err{err: _} => (*def).clone()
    }
}
pub fn std_unwrap_or_default_std_Option__A_1<A: Val>(opt: & std_Option<A>) -> A
{   std_option_unwrap_or_default(opt)
}
pub fn std_unwrap_or_default_std_Result__V_E_1<V: Val,E: Val>(res: & std_Result<V, E>) -> V
{   std_result_unwrap_or_default(res)
}
pub fn typeof_literal(literal: & internment_Intern<LiteralVal>) -> internment_Intern<TypeKind>
{   let ref mut ty: TypeKind = match (*internment_ival(literal)) {
                                   LiteralVal::String{str: _} => (TypeKind::Str{}),
                                   LiteralVal::Boolean{boolean: _} => (TypeKind::Bool{}),
                                   LiteralVal::Integer{int: _} => (TypeKind::Int{is_signed: (std_Option::std_None{}), width: (std_Option::std_None{})})
                               };
    internment_intern(ty)
}
pub fn unknown_type_errors(item: & Item) -> std_Vec<String>
{   match (*item) {
        Item::ItemFunc{func: ref func} => {
                                              let ref mut errors: std_Vec<String> = (*(&*__STATIC_5)).clone();
                                              for arg in func.args.iter() {
                                                  if ((&*internment_ival((&arg.kind))) == (&*(&(TypeKind::Unknown{})))) {
                                                      std_push(errors, (&String::from(r###"Function arguments cannot be unknown"###)))
                                                  } else {
                                                      ()
                                                  }
                                              };
                                              if ((&*internment_ival((&func.ret))) == (&*(&(TypeKind::Unknown{})))) {
                                                  std_push(errors, (&String::from(r###"Function return types cannot be unknown"###)))
                                              } else {
                                                  ()
                                              };
                                              (*errors).clone()
                                          },
        Item::ItemStruct{} => (*(&*__STATIC_5)).clone()
    }
}